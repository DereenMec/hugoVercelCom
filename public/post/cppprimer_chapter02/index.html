<!DOCTYPE html>
<html lang="zh-cn" itemscope itemtype="http://schema.org/WebPage">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>CppPrimer02.变量和基本类型 - Dereen - 深海游泳</title>
  

<meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta name="MobileOptimized" content="width"/>
<meta name="HandheldFriendly" content="true"/>


<meta name="applicable-device" content="pc,mobile">

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">

<meta name="mobile-web-app-capable" content="yes">

<meta name="author" content="Dereen" />
  <meta name="description" content="本章主要介绍内置类型，并初步说明C&#43;&#43;语言是如何支持更复杂数据类型的。
" />

  <meta name="keywords" content="Blog, 博客, C&#43;&#43;, Python, AI" />






<meta name="generator" content="Hugo 0.69.0" />


<link rel="canonical" href="https://happy.dereen.top/post/cppprimer_chapter02/" />





<link rel="icon" href="/favicon.ico" />











<link rel="stylesheet" href="/sass/jane.min.af20b78e95c84de86b00a0242a4a77bd2601700e1b250edf27537d957ac0041d.css" integrity="sha256-ryC3jpXITehrAKAkKkp3vSYBcA4bJQ7fJ1N9lXrABB0=" media="screen" crossorigin="anonymous">





<meta property="og:title" content="CppPrimer02.变量和基本类型" />
<meta property="og:description" content="本章主要介绍内置类型，并初步说明C&#43;&#43;语言是如何支持更复杂数据类型的。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://happy.dereen.top/post/cppprimer_chapter02/" />
<meta property="article:published_time" content="2020-04-24T12:57:12+08:00" />
<meta property="article:modified_time" content="2020-04-24T12:57:12+08:00" />
<meta itemprop="name" content="CppPrimer02.变量和基本类型">
<meta itemprop="description" content="本章主要介绍内置类型，并初步说明C&#43;&#43;语言是如何支持更复杂数据类型的。">
<meta itemprop="datePublished" content="2020-04-24T12:57:12&#43;08:00" />
<meta itemprop="dateModified" content="2020-04-24T12:57:12&#43;08:00" />
<meta itemprop="wordCount" content="1058">



<meta itemprop="keywords" content="C&#43;&#43;,学习笔记," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="CppPrimer02.变量和基本类型"/>
<meta name="twitter:description" content="本章主要介绍内置类型，并初步说明C&#43;&#43;语言是如何支持更复杂数据类型的。"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->




</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Dereen</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://happy.dereen.top/">主页</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://happy.dereen.top/post/">归档</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://happy.dereen.top/tags/">标签</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://happy.dereen.top/categories/">分类</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://happy.dereen.top/about/">关于</a>
          
        
      </li>
    

    
  </ul>
</nav>


  
    






  <link rel="stylesheet" href="/lib/photoswipe/photoswipe.min.css" />
  <link rel="stylesheet" href="/lib/photoswipe/default-skin/default-skin.min.css" />




<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

<div class="pswp__bg"></div>

<div class="pswp__scroll-wrap">
    
    <div class="pswp__container">
      <div class="pswp__item"></div>
      <div class="pswp__item"></div>
      <div class="pswp__item"></div>
    </div>
    
    <div class="pswp__ui pswp__ui--hidden">
    <div class="pswp__top-bar">
      
      <div class="pswp__counter"></div>
      <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
      <button class="pswp__button pswp__button--share" title="Share"></button>
      <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
      <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
      
      
      <div class="pswp__preloader">
        <div class="pswp__preloader__icn">
          <div class="pswp__preloader__cut">
            <div class="pswp__preloader__donut"></div>
          </div>
        </div>
      </div>
    </div>
    <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
      <div class="pswp__share-tooltip"></div>
    </div>
    <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
    </button>
    <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
    </button>
    <div class="pswp__caption">
      <div class="pswp__caption__center"></div>
    </div>
    </div>
    </div>
</div>

  

  

  

  <header id="header" class="header container">
    <div class="logo-wrapper">
  <a href="/" class="logo">
    
      Dereen
    
  </a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://happy.dereen.top/">主页</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://happy.dereen.top/post/">归档</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://happy.dereen.top/tags/">标签</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://happy.dereen.top/categories/">分类</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://happy.dereen.top/about/">关于</a>
          

        

      </li>
    

    
    

    
  </ul>
</nav>

  </header>

  <div id="mobile-panel">
    <main id="main" class="main bg-llight">
      <div class="content-wrapper">
        <div id="content" class="content container">
          <article class="post bg-white">
    
    <header class="post-header">
      <h1 class="post-title">CppPrimer02.变量和基本类型</h1>
      
      <div class="post-meta">
        <time datetime="2020-04-24" class="post-time">
          2020-04-24
        </time>
        <div class="post-category">
            
          </div>
        <span class="more-meta"> 1058 words </span>
          <span class="more-meta"> 5 min read </span>

        
        

        
        
      </div>
    </header>

    
    
<div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Table of Contents</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#基本数据类型"><strong>基本数据类型</strong></a>
      <ul>
        <li><a href="#算术类型"><strong>算术类型</strong></a></li>
        <li><a href="#字节和字"><strong>字节和字</strong></a></li>
        <li><a href="#带符号类型和无符号类型"><strong>带符号类型和无符号类型</strong></a></li>
        <li><a href="#如何选择类型"><strong>如何选择类型</strong></a></li>
        <li><a href="#类型转换"><strong>类型转换</strong></a></li>
        <li><a href="#字面值常量"><strong>字面值常量</strong></a></li>
      </ul>
    </li>
    <li><a href="#变量">变量</a>
      <ul>
        <li><a href="#变量定义">变量定义</a></li>
        <li><a href="#变量声明和定义的关系">变量声明和定义的关系</a></li>
        <li><a href="#标识符">标识符</a></li>
        <li><a href="#名字的作用域">名字的作用域</a></li>
      </ul>
    </li>
    <li><a href="#复合类型">复合类型</a>
      <ul>
        <li><a href="#引用">引用</a></li>
        <li><a href="#指针">指针</a></li>
        <li><a href="#理解复合类型的声明">理解复合类型的声明</a></li>
      </ul>
    </li>
    <li><a href="#const限定符">const限定符</a>
      <ul>
        <li><a href="#默认状态下const对象仅在文件内有效">默认状态下，const对象仅在文件内有效</a></li>
        <li><a href="#const的引用">const的引用</a></li>
        <li><a href="#指针和const">指针和const</a></li>
        <li><a href="#顶层const">顶层const</a></li>
        <li><a href="#constexpr和常量表达式">constexpr和常量表达式</a></li>
      </ul>
    </li>
    <li><a href="#处理类型">处理类型</a>
      <ul>
        <li><a href="#类型别名">类型别名</a></li>
        <li><a href="#auto类型说明符">auto类型说明符</a></li>
        <li><a href="#decltype类型的指示符">decltype类型的指示符</a></li>
      </ul>
    </li>
    <li><a href="#自定义数据结构">自定义数据结构</a>
      <ul>
        <li><a href="#定义sales_data类型">定义Sales_data类型</a></li>
        <li><a href="#编写自己的头文件">编写自己的头文件</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>

    
    <div class="post-content">
      <p>本章主要介绍内置类型，并初步说明C++语言是如何支持更复杂数据类型的。</p>
<h2 id="基本数据类型"><strong>基本数据类型</strong></h2>
<p>C++定义了一套包括算术类型和空类型在内的基本数据类型。其中算术类型包括了字符、整数型、布尔值和浮点型。**空类型不对应任何具体的值，仅用于一些特殊场合，**例如当函数不返回任何值时使用空类型作为其返回值。</p>
<h3 id="算术类型"><strong>算术类型</strong></h3>
<p>算数类型分为两类，整型（包括字符和布尔类型）和浮点型。</p>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">含义</th>
<th align="center">最小尺寸</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">bool</td>
<td align="center">布尔类型</td>
<td align="center">未定义</td>
</tr>
<tr>
<td align="center">char</td>
<td align="center">字符</td>
<td align="center">8位</td>
</tr>
<tr>
<td align="center">wchar_t</td>
<td align="center">宽字符</td>
<td align="center">16位</td>
</tr>
<tr>
<td align="center">char16_t</td>
<td align="center">Unicode字符</td>
<td align="center">16位</td>
</tr>
<tr>
<td align="center">char32_t</td>
<td align="center">Unicode字符</td>
<td align="center">32位</td>
</tr>
<tr>
<td align="center">short</td>
<td align="center">短整型</td>
<td align="center">16位</td>
</tr>
<tr>
<td align="center">int</td>
<td align="center">整型</td>
<td align="center">16位</td>
</tr>
<tr>
<td align="center">long</td>
<td align="center">长整型</td>
<td align="center">32位</td>
</tr>
<tr>
<td align="center">long long</td>
<td align="center">长整型</td>
<td align="center">64位</td>
</tr>
<tr>
<td align="center">float</td>
<td align="center">单精度浮点数</td>
<td align="center">6位有效数字</td>
</tr>
<tr>
<td align="center">double</td>
<td align="center">双精度浮点数</td>
<td align="center">10位有效数字</td>
</tr>
<tr>
<td align="center">long double</td>
<td align="center">扩展精度浮点数</td>
<td align="center">10位有效数字</td>
</tr>
</tbody>
</table>
<p>C++提供了多种字符类型，基本的字符类型是char，一个char的空间应确保可以存放机器基本字符集中任意字符对应的数字值。也就是说，<strong>一个char的大小和一个机器字节一样。</strong></p>
<blockquote>
<p>机器字长是指计算机进行一次整数运算所能处理的二进制数据的位数（整数运算即定点整数运算）。因为计算机中数的表示有定点数和浮点数之分，定点数又有定点整数和定点小数之分，这里所说的整数运算即定点整数运算。机器字长也就是运算器进行定点数运算的字长，通常也是CPU内部数据通道的宽度。</p>
</blockquote>
<h3 id="字节和字"><strong>字节和字</strong></h3>
<p>💡大多数计算机以2的整数次幂个比特（bit）作为块来处理内存，可寻址的最小内存块成为“字节（byte）”，存储的基本单元称为“字（word）”，它通常由几个字节组成。在C++语言中，一个字节要至少能容纳机器基本字符集中的字符。大多数计算机的字节由8bit构成，字则由32或64bit构成，也就是4或8字节。</p>
<h3 id="带符号类型和无符号类型"><strong>带符号类型和无符号类型</strong></h3>
<p>除去布尔和扩展的字符型之外，其他整型可以划分为带符号的和无符号的两种。带符号的可表示正数、负数或0，无符号类型则仅能表示大于等于0的值。通过在类型前加上unsigned标识即可定义一个无符号类型，例如：unsigned int。</p>
<p>与上面所述不同的是，字符型被分为了3种：char、signed char和unsigned char。需要注意的是，类型char和类型signed char并不相同。尽管字符型有三种，但是字符的表现形式却只有两种：带符号的和无符号的，类型char实际上会表现为哪一种由编译器决定。</p>
<h3 id="如何选择类型"><strong>如何选择类型</strong></h3>
<ul>
<li>当明确数值不可能为负时，选用无符号类型</li>
<li>使用int执行整形运算，如果数值超过了int的表示范围，选用long long</li>
<li>执行浮点数运算选用double，这是因为其计算代价与float相差无几，而精度反而更高</li>
</ul>
<h3 id="类型转换"><strong>类型转换</strong></h3>
<p>自动类型转换：</p>
<ul>
<li>当我们把一个非布尔类型的算数值赋给布尔类型时，初始值为0则结果为false，否则结果为true</li>
<li>当我们把一个布尔值赋给非布尔类型时，true变为1，false则变为0</li>
<li>当我们把浮点型赋给整型时，只保留整数部分的值</li>
<li>当我们把一个整数值赋给浮点类型时，小数部分为0，如果该整数所占的空间超过了浮点类型的容量，精度可能有损失</li>
<li>**当我们赋给无符号类型一个超出它表示范围的值时，结果是初始值对无符号类型的表示数值总数取模后的余数。**例如，将-1赋给一个unsigned char，则结果为255()</li>
</ul>
<p>💡无符号类型和带符号类型做运算时，带符号类型会首先被转换为无符号类型再做运算，这样造成的结果往往是未知的。</p>
<h3 id="字面值常量"><strong>字面值常量</strong></h3>
<p>一个形如82的值被称作字面值常量，这样的值一看便知。每个字面值常量都对应一种数据类型，字面值常量的形式和值决定了它的数据类型。</p>
<h4 id="整型和浮点型字面值"><strong>整型和浮点型字面值</strong></h4>
<p>我们可以将整型字面值写作十进制数、八进制数或十六进制数的形式。以0开头的整数代表八进制数，以0x或0X开头的代表十六进制数。20的三种表示方法：20、024、0x14。</p>
<p>整型字面值具体的数据类型由它的值和符号决定。**默认情况下，十进制字面值是带符号数，八进制和十六进制字面值极可能是带符号的也可能是无符号的。**十进制字面值的类型是int、long、long long中尺寸最小的那个，当然前提是能够容纳下当前的值。八进制和十六进制字面值的类型是能容纳其数值的int、unsigned int、long、unsigned long、long long和unsigned long long中的尺寸最小者。</p>
<p>💡尽管整型字面值可以存储在带符号数据类型中，但严格来说，十进制字面值不会是负数。如果我们使用了一个形如-42的负十进制字面值，那个负号并不在字面值之内，它的作用仅仅是对字面值取负值而已。</p>
<p>浮点型字面值表现为一个小数或以科学计数法表示的指数，其中指数部分使用E或e标识：3.1415926、3.14159E0、0.、0e0、.001，默认的浮点型字面值是一个double。</p>
<h4 id="字符和字符串字面值">字符和字符串字面值</h4>
<p>‘a’：字符字面值，默认类型为char</p>
<p>“Hello”：字符串字面值，默认类型为常量字符构成的数组，即const char[]</p>
<p>💡编译器会在每个字符串的结尾处添加一个空字符（'\0&rsquo;），因此字符串字面值的实际长度要比它的内容多1。</p>
<h4 id="转义序列">转义序列</h4>
<p>有两类字符程序员不能直接使用：一类是不可打印的字符，如退格或其他控制字符，因为它们没有可视的图符；另一类是在C++语言中有特殊含义的字符（单引号、双引号、问号、反斜杠）。在这些情况下需要使用转义序列，转义序列均以反斜杠作为开始，C++语言规定的转义序列包括：</p>
<pre><code>换行符		\\n		横向制表符	\\t		报警(响铃)符	\\a
纵向制表符	\\v		退格符		\\b		双引号			\\&quot;
反斜线		\\\\		问号		\\?		单引号			\\'
回车符		\\r		换页符		\\f
</code></pre><p>除此之外,<strong>我们也可以使用泛化的转义序列,其形式是\x后紧跟1个或多个十六进制数字，或\后紧跟1~3个八进制数字。其中数字部分表示的是字符对应的数值。例子：</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">	std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Hi </span><span style="color:#ae81ff">\\</span><span style="color:#e6db74">x4dO</span><span style="color:#ae81ff">\\</span><span style="color:#e6db74">115!</span><span style="color:#ae81ff">\\</span><span style="color:#e6db74">n&#34;</span>;  <span style="color:#75715e">// 输出Hi MOM！并换行
</span></code></pre></div><p>值得注意的是，如果\后面跟着的八进制数字超过3个，则只有前三个与\构成转义序列，而\x要用到后面跟着的所有数字。</p>
<h4 id="指定字面值的类型">指定字面值的类型</h4>
<p>通过添加下表中的前缀和后缀，可以改变整型、浮点型和字符型字面值的默认类型。</p>
<table>
<thead>
<tr>
<th align="center">前缀</th>
<th align="center">含义</th>
<th align="center">类型</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">u</td>
<td align="center">Unicode 16 字符</td>
<td align="center">char16_t</td>
</tr>
<tr>
<td align="center">U</td>
<td align="center">Unicode 32 字符</td>
<td align="center">char32_t</td>
</tr>
<tr>
<td align="center">L</td>
<td align="center">宽字符</td>
<td align="center">wchar_t</td>
</tr>
<tr>
<td align="center">u8</td>
<td align="center">UTF-8（仅用于字符串字面常量）</td>
<td align="center">char</td>
</tr>
</tbody>
</table>
<p>整型字面值（后缀）：</p>
<ul>
<li>u 或 U    unsigned</li>
<li>l 或 L    long</li>
<li>ll 或 LL    long long</li>
</ul>
<p>浮点型字面值（后缀）：</p>
<ul>
<li>f 或 F    float</li>
<li>l 或 L    long double</li>
</ul>
<h4 id="布尔字面值和指针字面值">布尔字面值和指针字面值</h4>
<p>true和false是布尔类型的字面值：bool test = false;</p>
<p><strong>nullptr是指针字面值。</strong></p>
<h2 id="变量">变量</h2>
<p>变量提供一个具名的、可供程序操作的**存储空间。**C++中的每个变量都有其数据类型，数据类型决定着变量所占内存空间的大小和布局方式，该空间能存储的值的范围，以及变量能参与的运算。对C++程序员来说，“变量”和“对象”一般可以互换使用。</p>
<p>💡一般认为对象是具有某种数据类型的内存空间。</p>
<h3 id="变量定义">变量定义</h3>
<p>变量定义的基本形式：类型说明符+一个或多个变量名组成的列表。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</code></pre></div><h4 id="初始值">初始值</h4>
<p>当对象在创建时获得了一个特定的值，我们说这个对象被初始化了。**当一次定义了两个或多个变量时，对象的名字随着定义也就马上可以使用了。**因此在同一条定义语句中，可以使用先定义的变量值初始化后定义的其他变量。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">double</span> price <span style="color:#f92672">=</span> <span style="color:#ae81ff">109.99</span>, discount <span style="color:#f92672">=</span> price <span style="color:#f92672">*</span> <span style="color:#ae81ff">0.7</span>;
</code></pre></div><p>初始化并不是赋值，初始化的含义是创建变量时赋予其一个初始值，而赋值的含义是把对象的当前值擦除，而以一个新值来替代。</p>
<h4 id="列表初始化">列表初始化</h4>
<p>C++语言定义了初始化的好几种不同形式，这也是初始化问题复杂性的一个体现。例如，要想定义一个名为units_sold的int变量并初始化为0，以下的4条语句都可以做到这一点：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">int</span> units_sold <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
<span style="color:#66d9ef">int</span> units_sold <span style="color:#f92672">=</span> {<span style="color:#ae81ff">0</span>};
<span style="color:#66d9ef">int</span> units_sold{<span style="color:#ae81ff">0</span>};
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">units_sold</span>(<span style="color:#ae81ff">0</span>);
</code></pre></div><p>使用花括号来为初始化变量被称为列表初始化，而且这种方法也可以用来为对象赋新值。<strong>当用于内置类型的变量时，这种初始化形式有一个重要特点：如果我们使用列表初始化且初始值存在丢失信息的风险，则编译器将报错。</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">long</span> <span style="color:#66d9ef">double</span> ld <span style="color:#f92672">=</span> <span style="color:#ae81ff">3.1415242131241</span><span style="color:#960050;background-color:#1e0010">；</span>
<span style="color:#66d9ef">int</span> a{ld}, b <span style="color:#f92672">=</span> {ld};   <span style="color:#75715e">// 错误：转换未执行，因为存在丢失信息的风险
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">c</span>(ld), c <span style="color:#f92672">=</span> ld;     <span style="color:#75715e">// 正确：转换执行，且确实丢失了精度
</span></code></pre></div><h4 id="默认初始化">默认初始化</h4>
<p>如果定义变量时没有指定初值，则变量被默认初始化，此时变量被赋予了“默认值”。默认值到底是什么由变量类型决定，同时定义变量的位置也会对此有影响。</p>
<h3 id="变量声明和定义的关系">变量声明和定义的关系</h3>
<p>为了增强代码的可读性，C++语言支持分离式编译机制，该机制允许将程序分割为若干个文件，每个文件可被独立编译。</p>
<p>为了支持分离式编译，C++语言将声明和定义区分开来。**声明（declaration）**使得名字为程序所知，<strong>一个文件如果想使用别处定义的名字则必须包含对那个名字的声明。</strong></p>
<p>💡变量声明规定了变量的类型和名字，在这一点上与变量的定义相同，但不同的是，定义还申请存储空间，也可能会为变量赋一个初始值。</p>
<p>如果想要声明一个变量而非定义它，就在变量名前加上关键字extern，而且不要显式的初始化变量；</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">extern</span> <span style="color:#66d9ef">int</span> i;  <span style="color:#75715e">// 声明i而非定义i
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> j;         <span style="color:#75715e">// 声明并定义j
</span></code></pre></div><p>💡变量能且只能被定义一次，但可以被声明多次。</p>
<h3 id="标识符">标识符</h3>
<p>C++的标识符（identifier）由字母、数字和下划线组成，其中必须以字母或下划线开头。标识符的长度没有限制，但是对大小写字母敏感。</p>
<p>⛔同时，C++也为标准库保留了一些名字，用户自定义的标识符中这些名字不能使用。<img src="https://raw.githubusercontent.com/DereenMec/pics/master/img/Untitled.png" alt="Untitled"></p>
<p><strong>同时，用户自定义的标识符中：</strong></p>
<ul>
<li>不能连续出现两个下划线</li>
<li>不能以下划线紧连大写字母开头</li>
<li>定义在函数体外的标识符不能以下划线开头</li>
</ul>
<h4 id="变量命名规范">变量命名规范</h4>
<ul>
<li>标识符要能体现具体含义</li>
<li>变量名一般使用小写字母，如index</li>
<li>用户自定义的类名一般以大写字母开头，如Sales_item</li>
<li>如果标识符由多个单词组成，则单词间应有明显区分，如student_loan或studentLoan</li>
</ul>
<h3 id="名字的作用域">名字的作用域</h3>
<p>作用域（scope）是程序的一部分，在其中名字有其特定的含义。C++中大多数作用域都以花括号分割。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">int</span> sum <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> val <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; val <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">10</span>; <span style="color:#f92672">++</span>val) sum <span style="color:#f92672">+=</span> val;
    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Sum of 1 to 10 inclusive is &#34;</span> <span style="color:#f92672">&lt;&lt;</span> sum <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><p>定义在函数体之外的名字拥有<strong>全局作用域</strong>（global scope），一旦声明之后，全局作用域内的名字在整个程序的范围内都可使用，如main。名字sum定义于main函数所限定的作用域之内，从声明sum到main函数结束为止都可访问它，但是除了main函数所在的块就无法访问了，因此说变量sum拥有<strong>块作用域</strong>（block scope）。名字val定义与for语句内，在for语句之内可以访问val，但是在main函数的其他位置就不能访问它了。</p>
<p>💡一般来说，在对象第一次被使用的地方附近定义它是一种好的选择，因为这样做有助于更容易地找到变量的定义。</p>
<h4 id="嵌套的作用域">嵌套的作用域</h4>
<p>作用域能够彼此嵌套或称包含，被包含的作用域称为内层作用域，包含着别的作用域的作用域被称为外层作用域。</p>
<p>作用域中一旦声明了某个名字，它的内层作用域中都能访问该名字，同时，允许在内层作用域中重新定义外层作用域已有的名字。</p>
<p>❗如果函数有可能用到某全局变量，则不宜在定义一个同名的局部变量。</p>
<h2 id="复合类型">复合类型</h2>
<p>复合类型（compound type）是指基于其他类型定义的类型。C++语言有几种复合类型，这里介绍指针和引用。</p>
<h3 id="引用">引用</h3>
<p>引用（reference）为对象起了另一个名字，<strong>引用类型</strong>引用另一种类型。通过将声明符写成&amp;d的形式来定义引用类型，其中d是声明的变量名。<strong>一旦初始化完成，引用将和它的初始值对象一直绑定在一起。因为无法将引用重新绑定到其他对象上，所以引用必须初始化。</strong></p>
<p>因为引用本身不是一个对象，所以不能定义引用的引用。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">int</span> a <span style="color:#f92672">=</span> <span style="color:#ae81ff">3</span>;
<span style="color:#66d9ef">int</span> <span style="color:#f92672">&amp;</span>b <span style="color:#f92672">=</span> a;
b <span style="color:#f92672">=</span> <span style="color:#ae81ff">4</span>;
std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> a <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;  <span style="color:#75715e">//输出为4
</span></code></pre></div><h3 id="指针">指针</h3>
<p>指针（pointer）是指向另一种类型的复合类型。指针与引用类似，也实现了对其他对象的间接访问。然而指针与引用相比有很多的不同点：</p>
<ul>
<li>指针本身就是一个对象，允许对指针赋值和拷贝，而且在指针的生命周期内它可以先后指向几个不同的对象</li>
<li>指针无需在定义时赋初值。和其他内置类型一样，在块作用域内定义的指针如果没有被初始化，也将拥有一个不确定的值。</li>
</ul>
<h4 id="获取对象的地址">获取对象的地址</h4>
<p>指针存放某个对象的地址，要想获取该地址，需要使用<strong>取地址符（操作符&amp;）：</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">int</span> val <span style="color:#f92672">=</span> <span style="color:#ae81ff">42</span><span style="color:#960050;background-color:#1e0010">；</span>
<span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>p <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>val;
</code></pre></div><p><strong>因为引用不是对象，没有实际地址，所以不能定义指向引用的指针。</strong></p>
<p>因为在声明语句中指针的类型实际上被用于指定他所指向对象的类型，所以二者必须匹配。如果指针指向了一个其他类型的对象，对该对象的操作将发生错误。</p>
<h4 id="指针值">指针值</h4>
<p>指针的值（即地址）应该属于下列4种状态之一：</p>
<ol>
<li>指向一个对象。</li>
<li>指向紧邻对象所占空间的下一个位置。</li>
<li>空指针，意味着指针没有指向任何对象。</li>
<li>无效指针，也就是上述情况之外的其他值。</li>
</ol>
<h4 id="利用指针访问对象">利用指针访问对象</h4>
<p>如果指针指向了一个对象，则允许使用解引用符（*）来访问该对象：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">int</span> val <span style="color:#f92672">=</span> <span style="color:#ae81ff">42</span>;
<span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>p <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>val;
<span style="color:#f92672">*</span>p <span style="color:#f92672">=</span> <span style="color:#ae81ff">43</span>;
std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> val <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;  <span style="color:#75715e">//输出43
</span></code></pre></div><h4 id="空指针">空指针</h4>
<p>空指针（null pointer）不指向任何对象，在试图使用一个指针之前代码可以首先检查它是否为空。以下列出几个生成空指针的方法：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>p1 <span style="color:#f92672">=</span> <span style="color:#66d9ef">nullptr</span>;  <span style="color:#75715e">// C++11中引入
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>p2 <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;

<span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cstdlib&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>p3 <span style="color:#f92672">=</span> NULL;
</code></pre></div><p>💡在新标准下，现在的C++程序最好使用nullptr，同时尽量避免使用NULL。</p>
<p><strong>把int变量直接赋给指针是错误的操作，即使int变量的值恰好等于0也不行。</strong></p>
<p>💡建议初始化所有指针。</p>
<h4 id="其他指针操作">其他指针操作</h4>
<p>只要指针拥有一个合法值，就能将他用在条件表达式中。和采用算数值作为条件遵循的规则类似，如果指针的值是0（即是一个空指针），条件取false，否则取true。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cstdlib&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>p1 <span style="color:#f92672">=</span> <span style="color:#66d9ef">nullptr</span>;
    <span style="color:#66d9ef">if</span> (p1) std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;p1&#34;</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;  <span style="color:#75715e">// p1不会输出
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> a;
    <span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>p2 <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>a;
    <span style="color:#66d9ef">if</span> (p2) std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;p2&#34;</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;  <span style="color:#75715e">// p2会被打印
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h4 id="void指针">void*指针</h4>
<p>void<em>指针是一种特殊的指针类型，可用于存放任意对象的地址。一个void</em>指针存放着一个地址。这一点和其他指针类似。不同的是，我们对改地址中到底是个什么类型的对象并不了解。</p>
<p>⛔不能直接操作void*指针所指的对象，因为我们并不知道这个对象到底是什么类型，也就无法确定能在这个对象上做哪些操作。</p>
<h3 id="理解复合类型的声明">理解复合类型的声明</h3>
<p>变量的定义包括一个基本数据类型和一组声明符（*和&amp;是声明符的一部分罢了）。在同一条定义语句中虽然基本数据类型只有一个，但是声明符的形式却可以不同。也就是说，一条定义语句可能定义出不同类型的变量：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">42</span>, <span style="color:#f92672">&amp;</span>j <span style="color:#f92672">=</span> i, <span style="color:#f92672">*</span>p <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>i;
<span style="color:#75715e">// i是一个int型的数，p是一个int型指针，r是一个int型引用。
</span></code></pre></div><h4 id="指向指针的指针">指向指针的指针</h4>
<p>一般来说，声明符中的修饰符（*和&amp;）个数并没有限制。当有多个修饰符连写到一起的时候，按照其逻辑关系祥加解释即可。以指针为例：</p>
<p>通过*的个数可以区分指针的级别。也就是说，**表示指向指针的指针，***表示指向指针的指针的指针。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">int</span> val <span style="color:#f92672">=</span> <span style="color:#ae81ff">42</span>;
<span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>p1 <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>val;  <span style="color:#75715e">// p1是一个int型指针
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#f92672">**</span>p2 <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>p1;  <span style="color:#75715e">// p2是一个指向int型指针的指针
</span></code></pre></div><h4 id="指向指针的引用">指向指针的引用</h4>
<p>引用本身不是一个对象，因此不能定义指向引用的指针，但是我们可以定义指针的引用：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">int</span> val <span style="color:#f92672">=</span> <span style="color:#ae81ff">42</span>;
<span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>p <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>val;
<span style="color:#66d9ef">int</span> <span style="color:#f92672">*&amp;</span>r <span style="color:#f92672">=</span> p;
std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#f92672">*</span>r <span style="color:#f92672">&lt;&lt;</span>std<span style="color:#f92672">::</span>endl; <span style="color:#75715e">// 输出42
</span></code></pre></div><p>💡要理解r的类型到底是什么，我们可以采用<strong>从右向左阅读法</strong>。离变量名最近的符号（如上面例子中的&amp;）对变量的类型有最直接的影响，因此r是一个引用。声明符的其余部分用以确定r引用的类型是什么，此例中的符号*说明r引用的是一个指针。最后，声明的基本数据类型部分指出r引用的是一个int型指针。</p>
<h2 id="const限定符">const限定符</h2>
<p>有时我们需要定义一种值不能被改变的变量。例如，用一个变量来表示固定的缓冲区的大小。巍峨了满足这一要求，可以用关键字const对变量的类型加以限定：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">42</span>;
</code></pre></div><p><strong>因为const对象一旦创建后其值就不能再改变，所以const对象必须初始化。</strong></p>
<h3 id="默认状态下const对象仅在文件内有效">默认状态下，const对象仅在文件内有效</h3>
<p>当以编译时初始化的方式定义一个const对象时，就如对bufSize的定义一样：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> bufSize <span style="color:#f92672">=</span> <span style="color:#ae81ff">512</span>;
</code></pre></div><p>编译器将在编译过程中把用到该变量的地方都替换成对应的值。也就是说，编译器会找到代码中所有用到bufSize的地方，然后以512替换。为了执行这个替换，编译器必须知道变量的初始值。如果程序存在多个文件，则每个用了const对象的文件都必须得能访问到它的初始值才行。<strong>要做到这一点，就必须在每一个用到变量的文件中都有对它的定义。</strong></p>
<p>💡为了支持这一用法，同时避免对同一变量的重复定义，默认情况下，const对象被设置为只在当前文件内有效。当多个文件中出现了同名的const变量时，其实等同于在不同文件中分别定义了独立的变量。</p>
<p>某些时候有这样一种const，**它的初始值不是一个常量表达式，**但又确实有必要在文件间共享。这种情况下，我们不希望编译器为每个文件生成独立的变量。相反，我们希望这类const对象向其他非常量对象一样工作，<strong>也就是说只在一个文件中定义，而在多个文件中使用。解决办法是：对于const变量不管是声明还是定义都添加extern关键字，这样只需定义一次就够了。</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">// file_1.cpp定义并初始化了一个常量，该常量能被其他文件访问
</span><span style="color:#75715e"></span><span style="color:#66d9ef">extern</span> <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> bufSize <span style="color:#f92672">=</span> <span style="color:#ae81ff">512</span>;
<span style="color:#75715e">// file_1.h头文件
</span><span style="color:#75715e"></span><span style="color:#66d9ef">extern</span> <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> bufSize;  <span style="color:#75715e">//与file_1.cpp中的bufSize为同一个
</span></code></pre></div><h3 id="const的引用">const的引用</h3>
<p>可以把引用绑定到const对象上，我们称之为对常量的引用。与普通引用不同的是，<strong>对常量的引用不能被用作修改它所绑定的对象。</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> bufSize <span style="color:#f92672">=</span> <span style="color:#ae81ff">512</span>;
<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> <span style="color:#f92672">&amp;</span>r1 <span style="color:#f92672">=</span> bufSize;
r1 <span style="color:#f92672">=</span> <span style="color:#ae81ff">513</span>;  <span style="color:#75715e">// 会出错❗，不允许修改
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#f92672">&amp;</span>r2 <span style="color:#f92672">=</span> bufSize;  <span style="color:#75715e">//会出错❗，不允许把非常量引用绑定到常量对象上
</span></code></pre></div><h4 id="初始化和对const的引用">初始化和对const的引用</h4>
<p>一般来说，引用的类型必须与其所引用对象的类型一致，但是也有两个例外：</p>
<ul>
<li>在初始化常量引用时允许使用任意表达式作为初始值，只要该表达式能够转换成引用的类型即可</li>
<li>允许一个常量引用绑定非常量的对象、字面值，甚至是个一般表达式</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">double</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">42.14</span>;
<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> <span style="color:#f92672">&amp;</span>r1 <span style="color:#f92672">=</span> i;  <span style="color:#75715e">// 注意❗，但伴随着精度损失
</span><span style="color:#75715e"></span>std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> r1 <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;  <span style="color:#75715e">// 合法，输出为42
</span><span style="color:#75715e"></span>std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> i <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;   <span style="color:#75715e">// 输出为42.14
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">512</span>;
<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> <span style="color:#f92672">&amp;</span>r2 <span style="color:#f92672">=</span> j; <span style="color:#75715e">// 合法
</span></code></pre></div><p>在例外一中，编译过程发生了下面的事情：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> temp <span style="color:#f92672">=</span> i;    <span style="color:#75715e">// 由双精度浮点数生成一个临时的整型常量
</span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> <span style="color:#f92672">&amp;</span>r1 <span style="color:#f92672">=</span> temp;  <span style="color:#75715e">// 让r1绑定这个临时量
</span></code></pre></div><p>在这种情况下，r1绑定了一个**临时量（temporary）对象。**所谓临时量对象就是当编译器需要一个空间来暂存表达式的求值结果时临时创建的一个未命名的对象。C++程序员常把临时量对象称为临时量。</p>
<p><strong>值得注意的是，类似于例外一的这种伴随类型转换的非常量引用都是非法的：</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">double</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">42.11</span>;
<span style="color:#66d9ef">int</span> <span style="color:#f92672">&amp;</span>r1 <span style="color:#f92672">=</span> i;
</code></pre></div><h3 id="指针和const">指针和const</h3>
<p>与引用一样，也可以令指针指向一个常量对象，<strong>指向常量对象的指针不能改变其所指对象的值，要想存放常量对象的地址，只能使用指向常量的指针。</strong></p>
<p>这里存在一种例外情况，即指向常量的指针可以指向一个非常量对象，所以下面的语句是合法的：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">double</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">42.11</span>;
<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">double</span><span style="color:#f92672">*</span> p <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>i;
</code></pre></div><h4 id="const指针">const指针</h4>
<p>**指针是对象而引用不是，所以允许把指针本身定义为常量。**这就意味着指针中存放的那个地址不可被改变，即不能更换指向的对象。把*放在const之前就可以说明指针是一个常量。</p>
<p>💡这里注意区分常量指针和指向常量的指针，<code>const int* p = &amp;i;</code>说明p是一个指向常量的指针，它指向的对象的值不可被改变，但是它指谁是可以被改变的；而<code>int* const p</code>则是一个常量指针，它指向的对象的值可以被改变，但是它指谁是不可变的。这两者可以同时使用，即<code>const int* const p</code>，造成的结果就是指谁和指的对象的值都不可改变。</p>
<h3 id="顶层const">顶层const</h3>
<p>鉴于指针本身是不是常量以及指针所指的对象是不是一个常量是两个独立的问题。用名词**顶层const（top-level const）表示指针本身是个常量，*<em>而用名词*<em>底层const（low-level const）表示指针所指对象是一个常量。</em></em></p>
<p>更一般的，**顶层const可以表示任意的对象是常量，这一点对任何数据类型都适用，**如算数类型、类、指针等。<strong>底层const则与指针和引用等<a href="https://www.notion.so/dereen/Chapter_02-3ae7c7c1804f4e1f8f64461b9b08ec77#8501b6ff46544a29a313d4655b27d8de">复合类型</a>的基本类型部分有关。</strong></p>
<p>💡指针的特殊之处在于它既可以是顶层const又可以是底层const。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">5123</span>;
<span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">const</span> p <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>i; <span style="color:#75715e">// 顶层const，即不能更换指向对象，但可改变所指对象的值
</span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> ci;  <span style="color:#75715e">// 顶层const
</span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>p2 <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>ci;  <span style="color:#75715e">// 底层const，即可以更换指向对象，但不可以改变所指对象的值
</span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">const</span> p3 <span style="color:#f92672">=</span> p2;  <span style="color:#75715e">// 既是顶层const，又是底层const
</span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> <span style="color:#f92672">&amp;</span>r <span style="color:#f92672">=</span> ci;  <span style="color:#75715e">//引用的const必然是底层const
</span></code></pre></div><p><strong>当执行拷贝操作时，常量是顶层const还是底层const带来的区别明显。其中顶层const不受什么影响。</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">i <span style="color:#f92672">=</span> ci;  <span style="color:#75715e">// 合法，拷贝ci的值，ci是一个顶层const，对此操作无影响
</span><span style="color:#75715e"></span>p2 <span style="color:#f92672">=</span> p3;  <span style="color:#75715e">// 合法，p2和p3所指向的对象相同，均为const int，p3的顶层const部分对此操作无影响
</span></code></pre></div><p><strong>而底层const（复合类型独有）的限制却不能忽略。当执行对象的拷贝操作时，拷入和拷出的对象必须具有相同的底层const资格，或者两个对象的数据类型必须能够转换（非const转为const，反之则不行）</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>p <span style="color:#f92672">=</span> p3;  <span style="color:#75715e">// 错误，p3包含底层const，想想要是p把通过p3都不允许改的值改了怎么办
</span><span style="color:#75715e"></span>p2 <span style="color:#f92672">=</span> p3; <span style="color:#75715e">// 正确，p2和p3都是底层const，都不允许修改指向对象的值
</span><span style="color:#75715e"></span>p2 <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>i; <span style="color:#75715e">// 正确，在这个过程中伴随着非const转为const
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#f92672">&amp;</span>r <span style="color:#f92672">=</span> ci; <span style="color:#75715e">// 错误，普通的int不能绑定到const int的ci身上
</span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> <span style="color:#f92672">&amp;</span>r2 <span style="color:#f92672">=</span> i;  <span style="color:#75715e">// 正确，int可以转为const int
</span></code></pre></div><h3 id="constexpr和常量表达式">constexpr和常量表达式</h3>
<p>常量表达式（const expression）是指值不会改变并且在编译过程就能得到计算结果的表达式。显然，<a href="https://www.notion.so/dereen/Chapter_02-3ae7c7c1804f4e1f8f64461b9b08ec77#f52d5c89fac248ff95da324151e9ac28">字面值</a>属于常量表达式。用字面值初始化的const对象也是常量表达式。</p>
<p><strong>一个对象（或表达式）是不是常量表达式由它的数据类型（是否为const）和初始值共同决定，例如：</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> max_files <span style="color:#f92672">=</span> <span style="color:#ae81ff">20</span>;               <span style="color:#75715e">// √
</span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> limit <span style="color:#f92672">=</span> max_files <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;        <span style="color:#75715e">// √
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> staff_size <span style="color:#f92672">=</span> <span style="color:#ae81ff">27</span>;                    <span style="color:#75715e">// 虽然staff_size的初始值是个字面值常量，但由于它的数据类型只是一个普通int，所以不是常量表达式
</span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> sz <span style="color:#f92672">=</span> get_size();              <span style="color:#75715e">// 虽然左侧是const int类型，但它的具体值直到运行时才能获取，所以也不是常量表达式
</span></code></pre></div><h4 id="constexpr变量">constexpr变量</h4>
<p>在实际工作中，我们很难分辨一个初始值到底是不是常量表达式。C++11新标准规定，允许<strong>将变量声明为constexpr类型以便由编译器自己检查变量的值是否是一个常量表达式。如果不是，就会报错。</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">constexpr</span> <span style="color:#66d9ef">int</span> mf <span style="color:#f92672">=</span> <span style="color:#ae81ff">22</span>;            <span style="color:#75715e">// √
</span><span style="color:#75715e"></span><span style="color:#66d9ef">constexpr</span> <span style="color:#66d9ef">int</span> sf <span style="color:#f92672">=</span> mf <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;        <span style="color:#75715e">// √
</span><span style="color:#75715e"></span><span style="color:#66d9ef">constexpr</span> <span style="color:#66d9ef">int</span> ef <span style="color:#f92672">=</span> size();        <span style="color:#75715e">// 只有当size()是一个constexpr函数时才是一条正确的语句
</span></code></pre></div><p>💡一般来说，如果你认定变量是一个常量表达式，那就把它声明成constexpr类型。</p>
<h4 id="字面值类型">字面值类型</h4>
<p>常量表达式的值需要在编译时就得到计算，所以能够声明成constexpr的类型就有限。因为这些类型一般比较简单，值也显而易见、容易得到，就把它们统称为“字面值类型”。算术类型、引用和指针都<strong>属于</strong>字面值类型。自定义类、IO库、string类型则<strong>不属于</strong>字面值类型。也就不能被定义为constexpr。</p>
<p>尽管指针和引用都能定义成constexpr，但它们的初始值却受到严格限制。一个constexpr指针的初始值必须是nullptr或者0，或者时存储与某个固定地址中的对象。一般来说，函数体内定义的变量并非存放在固定的地址中，因此constexpr指针不能指向这样的变量。相反的，定义与所有函数体之外的对象，其地址不变，能用来初始化constexpr指针。同时，函数体中定义的一类有效范围超出函数本身的变量，这类变量和定义在函数体之外的变量一样也有固定地址。因此，constexpr引用能绑定到这样的变量上，constexpr指针也能指向这样的变量。</p>
<h4 id="指针和constexpr">指针和constexpr</h4>
<p>在constexpr声明中如果定义了一个指针，限定符constexpr仅对指针有效，与指针所指的对象无关（顶层const）。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>p <span style="color:#f92672">=</span> <span style="color:#66d9ef">nullptr</span>;        <span style="color:#75715e">// 底层const，所指的对象的值不可变
</span><span style="color:#75715e"></span><span style="color:#66d9ef">constexpr</span> <span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>p <span style="color:#f92672">=</span> <span style="color:#66d9ef">nullptr</span>;    <span style="color:#75715e">// 顶层const，不能更换所指的对象
</span></code></pre></div><p>与其他常量指针类似，constexpr指针既可以指向常量对象，也可以指向非常量对象（只是通过这个指针不能修改）。</p>
<h2 id="处理类型">处理类型</h2>
<p>用于类型名称太复杂，写着写着就忘了，以及不知道返回值是什么类型的时候。</p>
<h3 id="类型别名">类型别名</h3>
<p>由两种方法为类型建立别名。一是<strong>typedef方法</strong>，二是<strong>using</strong>方法。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">double</span> base, <span style="color:#f92672">*</span>p;    <span style="color:#75715e">// base是double的同义词，p是double*的同义词
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> base <span style="color:#f92672">=</span> <span style="color:#66d9ef">double</span>;        
<span style="color:#66d9ef">using</span> p <span style="color:#f92672">=</span> <span style="color:#66d9ef">double</span><span style="color:#f92672">*</span>;          <span style="color:#75715e">// 同样的效果
</span></code></pre></div><h4 id="指针常量和类型别名">指针、常量和类型别名</h4>
<p>如果某个类型别名指代的是复合类型或常量，那么把它用到声明语句里就会产生意想不到的后果。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>pString;        <span style="color:#75715e">// pString是一个char*类型，即指向char对象的指针
</span><span style="color:#75715e"></span><span style="color:#66d9ef">char</span> a <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;A&#39;</span>;
<span style="color:#66d9ef">const</span> pString cstr <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>a;      <span style="color:#75715e">// const pString并不是const char*类型，而是char* const 类型
</span><span style="color:#75715e"></span><span style="color:#f92672">*</span>cstr <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;B&#39;</span>;                  <span style="color:#75715e">// 正确
</span><span style="color:#75715e"></span>cstr <span style="color:#f92672">=</span> <span style="color:#66d9ef">nullptr</span>;               <span style="color:#75715e">// 错误
</span></code></pre></div><h3 id="auto类型说明符">auto类型说明符</h3>
<p>C++11新标准引入了auto类型说明符，用它就能让编译器替我们去分析表达式所属的类型。和原来那些只对应一种特定类型的说明符（如int）不同，auto让编译器通过初始值来推算变量的类型。<strong>显然，auto定义的变量必须有初始值。</strong></p>
<p>💡使用auto也能在一条语句中声明多个变量。因为一条声明语句只能有一个基本数据类型，<strong>所以该语句中所有变量的初始基本数据类型都必须一样：</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">auto</span> sz <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, pi <span style="color:#f92672">=</span> <span style="color:#ae81ff">3.14</span>;      <span style="color:#75715e">// 错误，类型必须一致
</span><span style="color:#75715e"></span><span style="color:#66d9ef">auto</span> sz <span style="color:#f92672">=</span> <span style="color:#ae81ff">.0</span>, pi <span style="color:#f92672">=</span> <span style="color:#ae81ff">3.14</span>;     <span style="color:#75715e">// 正确
</span></code></pre></div><h4 id="复合类型常量和auto">复合类型、常量和auto</h4>
<p>auto一般会忽略掉顶层const，同时底层const会被保留下来，比如当初始值是一个指向常量的指针时。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> ci <span style="color:#f92672">=</span> <span style="color:#ae81ff">42</span>, <span style="color:#f92672">&amp;</span>cr <span style="color:#f92672">=</span> ci;
<span style="color:#66d9ef">auto</span> a <span style="color:#f92672">=</span> ci;                    <span style="color:#75715e">// a是一个整数，ci的顶层const特性被忽略了
</span><span style="color:#75715e"></span><span style="color:#66d9ef">auto</span> b <span style="color:#f92672">=</span> cr;                    <span style="color:#75715e">// b是一个整数，（cr是ci的别名，ci本身是一个顶层const）
</span><span style="color:#75715e"></span><span style="color:#66d9ef">auto</span> c <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>ci;                   <span style="color:#75715e">// c是一个指向整数常量的指针（对常量对象取地址是一种底层const）
</span></code></pre></div><p><strong>如果希望推断出的auto类型是一个顶层const，需要明确指出。</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">auto</span> f <span style="color:#f92672">=</span> ci;
</code></pre></div><p>还可以将引用的类型设置为auto，此时原来的初始化规则仍然适用。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">auto</span> <span style="color:#f92672">&amp;</span>g <span style="color:#f92672">=</span> ci;             <span style="color:#75715e">// 正确，g是一个整型常量引用，绑定到ci
</span><span style="color:#75715e"></span><span style="color:#66d9ef">auto</span> <span style="color:#f92672">&amp;</span>h <span style="color:#f92672">=</span> <span style="color:#ae81ff">42</span>;             <span style="color:#75715e">// 错误，不能为非常量引用绑定字面值
</span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">auto</span> <span style="color:#f92672">&amp;</span>s <span style="color:#f92672">=</span> <span style="color:#ae81ff">42</span>;       <span style="color:#75715e">// 正确，可以为常量引用绑定字面值
</span></code></pre></div><h3 id="decltype类型的指示符">decltype类型的指示符</h3>
<p>有时，我们希望从表达式的类型推断出要定义的变量的类型，但是**不想用该表达式的值初始化变量。*<em>为了满足这一要求，C++11新标准引入了第二种类型说明符decltype，它的作用是*<em>选择并返回操作数的数据类型，却不实际计算表达式的值。</em></em></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">decltype</span>(f()) sum <span style="color:#f92672">=</span> x;     <span style="color:#75715e">// sum的类型就是f的返回值类型
</span></code></pre></div><p>**decltype处理顶层const和引用的方式与auto有些不同。**如果decltype使用的表达式是一个变量，则decltype返回该变量的类型（包括顶层const和引用在内）：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> ci <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, <span style="color:#f92672">&amp;</span>cj <span style="color:#f92672">=</span> ci;
<span style="color:#66d9ef">decltype</span>(ci) x <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;              <span style="color:#75715e">// x的类型为const int
</span><span style="color:#75715e"></span><span style="color:#66d9ef">decltype</span>(cj) y <span style="color:#f92672">=</span> x;              <span style="color:#75715e">// y的类型为const int&amp;，绑定到变量x
</span><span style="color:#75715e"></span><span style="color:#66d9ef">decltype</span>(cj) z;                  <span style="color:#75715e">// 错误❗，z是一个引用，必须被初始化
</span></code></pre></div><p>💡引用从来都是作为其所指对象的同义词出现，只有用在decltype处是一个例外。</p>
<h4 id="decltype和引用">decltype和引用</h4>
<p>如果decltype使用的表达式不是一个变量，则decltype返回表达式结果对应的类型。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">42</span>, <span style="color:#f92672">*</span>p <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>i, <span style="color:#f92672">&amp;</span>r <span style="color:#f92672">=</span> i;
<span style="color:#66d9ef">decltype</span>(r <span style="color:#f92672">+</span> <span style="color:#ae81ff">0</span>) b;            <span style="color:#75715e">// 合法，加法表达式的结果是int，因此b是一个未初始化的int
</span><span style="color:#75715e"></span><span style="color:#66d9ef">decltype</span>(r) b;                <span style="color:#75715e">// 错误，引用必须初始化
</span><span style="color:#75715e"></span><span style="color:#66d9ef">decltype</span>(<span style="color:#f92672">*</span>p) c;               <span style="color:#75715e">// c是int&amp;，必须初始化
</span></code></pre></div><p>**💡如果表达式的内容是解引用操作，则decltype将得到引用类型。**正如我们所熟知的，解引用指针可以得到指针所指的对象，而且还能给这个对象赋值。因此decltype(*p)的结果类型就是int&amp;，而非int。</p>
<p>另一个例子显示了变量名加上一对括号和不加括号的区别：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">42</span>;
<span style="color:#66d9ef">decltype</span>((i)) d;             <span style="color:#75715e">// 错误：d是int&amp;，必须初始化
</span><span style="color:#75715e"></span><span style="color:#66d9ef">decltype</span>(i) e;               <span style="color:#75715e">// 正确，e是一个未初始化的int
</span></code></pre></div><p><strong>❗切记：decltype((variable))双层括号的结果永远是引用，而decltype(variable)结果只有当variable本身是一个引用时才是引用。</strong></p>
<h2 id="自定义数据结构">自定义数据结构</h2>
<p>从最基本的层面理解，数据结构是把一组相关的数据元素组织起来然后使用它们的策略和方法。</p>
<h3 id="定义sales_data类型">定义Sales_data类型</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Sales_data</span> {
    std<span style="color:#f92672">::</span>string bookNo;
    <span style="color:#66d9ef">unsigned</span> units_sold <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">double</span> revenue <span style="color:#f92672">=</span> <span style="color:#ae81ff">0.0</span>;
};
</code></pre></div><p>❗这里需要注意的是，不要漏掉花括号后面的分号，这是因为类体后面可以直接跟变量名，所以分号必不可少。</p>
<h4 id="类数据成员">类数据成员</h4>
<p>类的数据成员定义了类的对象的具体内容，每个对象有自己的一份数据成员拷贝。修改一个对象的数据成员，不会影响其他Sales_data的对象。</p>
<p>❗注意，对类内初始值的限制与之前类似；或者放在花括号里，或者放在等号右边，记住不可使用圆括号。</p>
<h3 id="编写自己的头文件">编写自己的头文件</h3>
<p>为了确保各个文件中类的定义一致，类通常被定义在头文件中，而且<strong>类所在头文件的名字应该与类的名字一样。</strong></p>
<h4 id="使用pragma-once确保不会重复包含">使用#pragma once确保不会重复包含</h4>
<p>确保头文件多次包含仍能安全工作的常用技术是预处理器（preprocessor）。例如#include，当预处理器看到#include标记时就会把该头文件内的全部内容复制到当前文件中来。</p>
<p>C++中常用的一项技术是头文件保护符（header guard），有两种方法用来避免头文件重复被包含。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#ifndef SALES_DATA_H
</span><span style="color:#75715e">#define SALES_DATA_H
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;string&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Sales_data</span> {
    std<span style="color:#f92672">::</span>string bookNo;
    <span style="color:#66d9ef">unsigned</span> units_sold <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">double</span> revenue <span style="color:#f92672">=</span> <span style="color:#ae81ff">0.0</span>;
};
<span style="color:#75715e">#endif
</span></code></pre></div><p>这种是使用<strong>ifndef</strong>方法；另一种方法是使用<strong>pragma once：</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#pragma once
</span></code></pre></div><p>💡头文件即使（目前还）没有被包含在任何头文件中，也应该设置保护符。头文件保护符很简单，程序员只要习惯性的加上就可以了，没必要太在乎你的程序到底需要不需要。</p>
    </div>

    
    
<div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">Author</span>
    <span class="item-content"><a href="https://happy.dereen.top/author/dereen/">Dereen</a></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">LastMod</span>
    <span class="item-content">
      2020-04-24
      
    </span>
  </p>
  
  <p class="copyright-item">
    <span class="item-title">License</span>
    <span class="item-content"><a rel="license noopener" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank">CC BY-NC-ND 4.0</a></span>
  </p>
</div>


    
    

    <footer class="post-footer">
      <div class="post-tags">
          <a href="https://happy.dereen.top/tags/c&#43;&#43;/">C&#43;&#43;</a>
          <a href="https://happy.dereen.top/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a>
          
        </div>

      
      <nav class="post-nav">
        
          <a class="prev" href="/post/cppprimer_chapter03/">
            
            <i class="iconfont">
              <svg  class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="18" height="18">
  <path d="M691.908486 949.511495l75.369571-89.491197c10.963703-12.998035 10.285251-32.864502-1.499144-44.378743L479.499795 515.267417 757.434875 204.940602c11.338233-12.190647 11.035334-32.285311-0.638543-44.850487l-80.46666-86.564541c-11.680017-12.583596-30.356378-12.893658-41.662889-0.716314L257.233596 494.235404c-11.332093 12.183484-11.041474 32.266891 0.657986 44.844348l80.46666 86.564541c1.772366 1.910513 3.706415 3.533476 5.750981 4.877077l306.620399 321.703933C662.505829 963.726242 680.945807 962.528973 691.908486 949.511495z"></path>
</svg>

            </i>
            <span class="prev-text nav-default">CppPrimer03.字符串、向量和数组</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        
          <a class="next" href="/post/cppprimer_chapter01/">
            <span class="next-text nav-default">CppPrimer01.开始</span>
            <span class="prev-text nav-mobile">Next</span>
            
            <i class="iconfont">
              <svg class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="18" height="18">
  <path d="M332.091514 74.487481l-75.369571 89.491197c-10.963703 12.998035-10.285251 32.864502 1.499144 44.378743l286.278095 300.375162L266.565125 819.058374c-11.338233 12.190647-11.035334 32.285311 0.638543 44.850487l80.46666 86.564541c11.680017 12.583596 30.356378 12.893658 41.662889 0.716314l377.434212-421.426145c11.332093-12.183484 11.041474-32.266891-0.657986-44.844348l-80.46666-86.564541c-1.772366-1.910513-3.706415-3.533476-5.750981-4.877077L373.270379 71.774697C361.493148 60.273758 343.054193 61.470003 332.091514 74.487481z"></path>
</svg>

            </i>
          </a>
      </nav>
    </footer>
  </article>

  
  
  
  

  
  

  

  
  
    <div class="post bg-white">
      <script src="https://utteranc.es/client.js"
            repo= "DereenMec/hugovercelcom"
            issue-term="pathname"
            theme="github-light"
            crossorigin="anonymous"
            async>
      </script>
    </div>
  

  

  

  

    

  

        </div>
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="icon-links">
  
  
    <a href="mailto:dereenmec@outlook.com" rel="me noopener" class="iconfont"
      title="email" >
      <svg class="icon" viewBox="0 0 1451 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="36" height="36">
  <path d="M664.781909 681.472759 0 97.881301C0 3.997201 71.046997 0 71.046997 0L474.477909 0 961.649408 0 1361.641813 0C1361.641813 0 1432.688811 3.997201 1432.688811 97.881301L771.345323 681.472759C771.345323 681.472759 764.482731 685.154773 753.594283 688.65053L753.594283 688.664858C741.602731 693.493018 729.424896 695.068979 718.077952 694.839748 706.731093 695.068979 694.553173 693.493018 682.561621 688.664858L682.561621 688.65053C671.644501 685.140446 664.781909 681.472759 664.781909 681.472759L664.781909 681.472759ZM718.063616 811.603883C693.779541 811.016482 658.879232 802.205449 619.10784 767.734955 542.989056 701.759633 0 212.052267 0 212.052267L0 942.809523C0 942.809523 0 1024 83.726336 1024L682.532949 1024 753.579947 1024 1348.948139 1024C1432.688811 1024 1432.688811 942.809523 1432.688811 942.809523L1432.688811 212.052267C1432.688811 212.052267 893.138176 701.759633 817.019477 767.734955 777.248 802.205449 742.347691 811.03081 718.063616 811.603883L718.063616 811.603883Z"></path>
</svg>

    </a>
  
    <a href="https://twitter.com/dereen_" rel="me noopener" class="iconfont"
      title="twitter"  target="_blank"
      >
      <svg class="icon" viewBox="0 0 1264 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="36" height="36">
  <path d="M1229.8616 18.043658c0 0-117.852626 63.135335-164.151872 67.344358-105.225559-164.151872-505.082682-92.598492-437.738325 223.078185C278.622548 312.675223 89.216542 47.506814 89.216542 47.506814s-117.852626 189.406006 75.762402 345.139833C127.097743 396.85567 55.544363 371.601535 55.544363 371.601535S26.081207 535.753407 253.368414 615.724832c-21.045112 29.463156-113.643603 8.418045-113.643603 8.418045s25.254134 143.10676 231.496229 180.987961c-143.10676 130.479693-387.230056 92.598492-370.393967 105.225559 206.242095 189.406006 1119.599946 231.496229 1128.01799-643.98042C1179.353331 249.539887 1263.533778 123.269217 1263.533778 123.269217s-130.479693 37.881201-138.897738 33.672179C1225.652577 98.015083 1229.8616 18.043658 1229.8616 18.043658"></path>
</svg>

    </a>
  
    <a href="https://www.facebook.com/xbzzhc" rel="me noopener" class="iconfont"
      title="facebook"  target="_blank"
      >
      <svg class="icon" style="" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="33" height="33">
  <path d="M965.7344 2.7648c14.848 0 28.2624 5.5296 40.2432 16.6912C1017.9584 30.5152 1024 43.52 1024 58.2656l0 910.2336c0 14.848-6.0416 27.7504-18.0224 38.8096C993.8944 1018.4704 980.48 1024 965.7344 1024L704.9216 1024 704.9216 629.9648l133.2224 0 19.456-155.4432-152.576 0L705.024 373.0432c0-50.688 25.9072-76.0832 77.7216-76.0832l80.4864 0L863.232 163.5328c-27.7504-5.4272-67.4816-8.192-119.296-8.192-59.1872 0-106.8032 18.0224-142.9504 54.0672C564.736 245.5552 546.7136 296.0384 546.7136 360.7552l0 113.7664L413.4912 474.5216l0 155.4432 133.2224 0L546.7136 1024 55.5008 1024c-14.848 0-27.7504-5.5296-38.8096-16.6912C5.5296 996.2496 0 983.3472 0 968.4992L0 58.2656C0 43.52 5.5296 30.5152 16.6912 19.456c11.0592-11.0592 24.064-16.6912 38.8096-16.6912L965.7344 2.7648z"></path>
</svg>

    </a>
  
    <a href="https://github.com/dereenmec" rel="me noopener" class="iconfont"
      title="github"  target="_blank"
      >
      <svg class="icon" style="" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="36" height="36">
  <path d="M512 12.672c-282.88 0-512 229.248-512 512 0 226.261333 146.688 418.133333 350.08 485.76 25.6 4.821333 34.986667-11.008 34.986667-24.618667 0-12.16-0.426667-44.373333-0.64-87.04-142.421333 30.890667-172.458667-68.693333-172.458667-68.693333C188.672 770.986667 155.008 755.2 155.008 755.2c-46.378667-31.744 3.584-31.104 3.584-31.104 51.413333 3.584 78.421333 52.736 78.421333 52.736 45.653333 78.293333 119.850667 55.68 149.12 42.581333 4.608-33.109333 17.792-55.68 32.426667-68.48-113.706667-12.8-233.216-56.832-233.216-253.013333 0-55.893333 19.84-101.546667 52.693333-137.386667-5.76-12.928-23.04-64.981333 4.48-135.509333 0 0 42.88-13.738667 140.8 52.48 40.96-11.392 84.48-17.024 128-17.28 43.52 0.256 87.04 5.888 128 17.28 97.28-66.218667 140.16-52.48 140.16-52.48 27.52 70.528 10.24 122.581333 5.12 135.509333 32.64 35.84 52.48 81.493333 52.48 137.386667 0 196.693333-119.68 240-233.6 252.586667 17.92 15.36 34.56 46.762667 34.56 94.72 0 68.522667-0.64 123.562667-0.64 140.202666 0 13.44 8.96 29.44 35.2 24.32C877.44 942.592 1024 750.592 1024 524.672c0-282.752-229.248-512-512-512"></path>
</svg>

    </a>
  
    <a href="https://weibo.com/xbzzhc" rel="me noopener" class="iconfont"
      title="weibo"  target="_blank"
      >
      <svg class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="36" height="36">
  <path d="M385.714286 733.714286q12-19.428571 6.285714-39.428571t-25.714286-28.571429q-19.428571-8-41.714286-0.571429t-34.285714 26.285714q-12.571429 19.428571-7.428571 39.142857t24.571429 28.857143 42.571429 1.428571 35.714286-27.142857zm53.714286-69.142857q4.571429-7.428571 2-15.142857t-10-10.571429q-8-2.857143-16.285714 2.857143t-12.285714 10.571429q-9.714286 17.714286 7.428571 25.714286 8 2.857143 16.571429 2.857143t12.571429-10.571429zm99.428571 61.142857q-25.714286 58.285714-90.285714 85.714286t-128 6.857143q-61.142857-19.428571-84.285714-72.285714t3.714286-107.142857q26.857143-53.142857 86.571429-79.428571t120.285714-10.857143q63.428571 16.571429 90.571429 68.285714t1.428571 108.857143zm178.285714-91.428571q-5.142857-54.857143-50.857143-97.142857t-119.142857-62.285714-156.857143-12q-127.428571 13.142857-211.142857 80.857143t-75.714286 151.142857q5.142857 54.857143 50.857143 97.142857t119.142857 62.285714 156.857143 12q127.428571-13.142857 211.142857-80.857143t75.714286-151.142857zm176 2.285714q0 38.857143-21.142857 79.714286t-62.285714 78.285714-96.285714 67.142857-129.142857 47.428571-154.571429 17.714286-157.142857-19.142857-137.428571-53.142857-98-86.285714-37.142857-114q0-65.714286 39.714286-140t112.857143-147.428571q96.571429-96.571429 195.142857-134.857143t140.857143 4q37.142857 36.571429 11.428571 119.428571-2.285714 8-0.571429 11.428571t5.714286 4 8.285714 2.857143 7.714286-2l3.428571-1.142857q79.428571-33.714286 140.571429-33.714286t87.428571 34.857143q25.714286 36 0 101.714286-1.142857 7.428571-2.571429 11.428571t2.571429 7.142857 6.857143 4.285714 9.714286 3.428571q32.571429 10.285714 58.857143 26.857143t45.714286 46.571429 19.428571 66.571429zm-42.285714-356.571429q24 26.857143 31.142857 62t-3.714286 67.142857q-4.571429 13.142857-16.857143 19.428571t-25.428571 2.285714q-13.142857-4.571429-19.428571-16.857143t-2.285714-25.428571q11.428571-36-13.714286-63.428571t-61.142857-20q-13.714286 2.857143-25.714286-4.571429t-14.285714-21.142857q-2.857143-13.714286 4.571429-25.428571t21.142857-14.571429q34.285714-7.428571 68 3.142857t57.714286 37.428571zm103.428571-93.142857q49.714286 54.857143 64.285714 127.142857t-7.714286 138q-5.142857 15.428571-19.428571 22.857143t-29.714286 2.285714-22.857143-19.428571-2.857143-29.714286q16-46.857143 5.714286-98.285714t-45.714286-90.285714q-35.428571-39.428571-84.571429-54.571429t-98.857143-4.857143q-16 3.428571-29.714286-5.428571t-17.142857-24.857143 5.428571-29.428571 24.857143-16.857143q70.285714-14.857143 139.428571 6.571429t118.857143 76.857143z"></path>
</svg>

    </a>
  
    <a href="https://space.bilibili.com/6509651" rel="me noopener" class="iconfont"
      title="bilibili"  target="_blank"
      >
      <svg
  class="icon" style="" viewBox="0 0 1024 1024" version="1.1" width="36"
  height="36" id="svg8">
  <path
      style=""
      d="M 744.60599,0.00486267 A 41.779915,41.779915 0 0 0 710.4184,18.673394 L 548.5048,255.32642 h -11.70046 a 41.779915,41.779915 0 0 0 -10.80295,-7.84928 L 235.66,97.084498 a 41.779915,41.779915 0 0 0 -20.07193,-4.960864 41.779915,41.779915 0 0 0 -18.3748,79.145436 L 359.4859,255.32642 H 128.16909 c -49.458302,0 -89.27932,39.82105 -89.27932,89.27932 v 508.65224 c 0,49.4583 39.821018,89.27934 89.27932,89.27934 h 19.48445 C 149.12802,984.5043 179.92773,1024 224.79179,1024 c 44.86407,0 75.66379,-39.4957 77.13826,-81.46268 H 719.98116 C 721.45559,984.5043 752.25533,1024 797.1194,1024 c 44.86406,0 75.6638,-39.4957 77.13824,-81.46268 h 21.57323 c 49.45831,0 89.27936,-39.82104 89.27936,-89.27934 V 344.60574 c 0,-49.45827 -39.82105,-89.27932 -89.27936,-89.27932 H 649.74567 L 779.38103,65.866924 A 41.779915,41.779915 0 0 0 744.60599,0.00486267 Z M 644.49108,418.70871 c 6.29985,0.21538 12.44451,2.01107 17.86888,5.22196 l 171.36218,98.10771 c 18.23417,10.21935 24.63334,33.34627 14.24614,51.48533 -10.38726,18.13909 -33.57344,24.32718 -51.61587,13.77296 L 624.9903,489.18895 c -15.21356,-8.41858 -22.66871,-26.1765 -18.03211,-42.93436 4.63664,-16.75784 20.15573,-28.14465 37.53289,-27.54588 z M 350.2006,432.31846 c 16.89952,0.0317 31.69582,11.33328 36.17844,27.62747 4.48262,16.2942 -2.44981,33.57765 -16.95507,42.24898 l -140.7157,86.91312 c -17.68528,11.18244 -41.09629,5.77692 -52.08912,-12.02686 -10.99282,-17.80373 -5.33855,-41.15658 12.58167,-51.95857 L 329.9002,438.2095 c 6.0643,-3.86439 13.10951,-5.90891 20.3004,-5.89104 z M 501.605,641.53985 c 3.75002,-0.15248 7.48645,0.53903 10.93349,2.0235 0.15842,0.0637 0.31618,0.12888 0.47325,0.19582 0.59328,0.27092 1.17574,0.56489 1.74609,0.88121 0.15868,0.0854 0.31643,0.17233 0.47325,0.2611 0.55694,0.32165 1.10131,0.66458 1.63185,1.02807 0.16455,0.1123 0.32777,0.2265 0.48956,0.34269 0.50382,0.36781 0.99371,0.75428 1.46868,1.15864 0.18724,0.15504 0.37218,0.31282 0.55484,0.47323 0.43271,0.38784 0.8518,0.79061 1.25653,1.20756 0.15449,0.16114 0.30679,0.32437 0.45693,0.48959 0.40798,0.44266 0.79989,0.89988 1.17494,1.37076 0.17799,0.22544 0.35205,0.45395 0.5222,0.68538 0.25932,0.34701 0.50964,0.70071 0.75064,1.06071 0.26712,0.39516 0.52286,0.79784 0.76699,1.20757 0.16907,0.29043 0.33231,0.58424 0.48957,0.88123 0.21836,0.41297 0.42513,0.83199 0.62009,1.25653 0.14836,0.32333 0.28983,0.64976 0.42429,0.97911 0.21319,0.51552 0.40915,1.03801 0.58747,1.5666 0.0677,0.19499 0.13296,0.39085 0.19582,0.58748 0.18652,0.60823 0.34984,1.22334 0.48957,1.84399 0.0397,0.16277 0.0779,0.32601 0.11423,0.48957 0.1436,0.69112 0.25788,1.38801 0.34269,2.08877 0.005,0.0381 0.0111,0.0761 0.0163,0.11424 0.0857,0.78056 0.13474,1.56471 0.14687,2.34988 0.005,0.0543 0.0111,0.10879 0.0163,0.1632 0,0 -0.008,1.12132 0,1.45234 0,0 -0.14697,17.84761 5.89102,34.12231 3.01902,8.13734 7.33278,15.10615 12.61433,19.61501 5.28157,4.50889 11.42894,7.62081 23.64572,7.62081 12.2168,0 18.36416,-3.11192 23.64573,-7.62081 5.28154,-4.50886 9.5953,-11.47767 12.6143,-19.61501 6.03799,-16.2747 5.89103,-34.12231 5.89103,-34.12231 -0.44885,-13.87045 10.45922,-25.46302 24.3311,-25.86506 13.87189,-0.40201 25.42828,10.53953 25.78348,24.41272 0,0 1.11929,25.7226 -9.00791,53.01927 -5.06359,13.64832 -13.1986,28.46036 -27.05631,40.29073 -13.85772,11.83039 -33.5454,19.63135 -56.20142,19.63135 -22.65603,0 -42.34371,-7.80096 -56.20141,-19.63135 -4.1801,-3.56856 -7.78733,-7.42433 -10.99878,-11.42303 -3.21235,4.00037 -6.81703,7.85309 -10.99876,11.42303 -13.85773,11.83039 -33.5454,19.63135 -56.20144,19.63135 -22.65601,0 -42.3437,-7.80096 -56.2014,-19.63135 -13.85775,-11.83037 -21.99272,-26.64241 -27.05632,-40.29073 -10.12725,-27.29667 -9.00789,-53.01928 -9.00789,-53.01927 0.20714,-13.83687 11.58744,-24.88848 25.42444,-24.69013 14.1263,0.19991 25.2971,12.0278 24.69011,26.14247 0,0 -0.14697,17.84761 5.89103,34.12231 3.01902,8.13734 7.31646,15.10615 12.598,19.61501 5.28155,4.50889 11.44526,7.62081 23.66203,7.62081 12.21681,0 18.36418,-3.11192 23.64573,-7.62081 5.28154,-4.50886 9.57899,-11.47767 12.598,-19.61501 5.76352,-15.53489 5.89112,-32.05691 5.89103,-33.56746 0.006,-0.37466 0.0111,-1.05336 0.0163,-1.20759 -0.0117,-0.74583 0.0105,-1.49177 0.0652,-2.23565 0.009,-0.15784 0.0204,-0.31561 0.0327,-0.47324 0.14204,-1.56859 0.43163,-3.12027 0.86487,-4.63449 0.0213,-0.0763 0.0433,-0.15244 0.0652,-0.22848 3.0335,-10.25748 12.24157,-17.46007 22.92769,-17.93417 z"
      id="rect824"/>
</svg>

    </a>


<a href="https://happy.dereen.top/index.xml" rel="noopener alternate" type="application/rss&#43;xml"
    class="iconfont" title="rss" target="_blank">
    <svg class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="30" height="30">
  <path d="M819.157333 1024C819.157333 574.592 449.408 204.8 0 204.8V0c561.706667 0 1024 462.293333 1024 1024h-204.842667zM140.416 743.04a140.8 140.8 0 0 1 140.501333 140.586667A140.928 140.928 0 0 1 140.074667 1024C62.72 1024 0 961.109333 0 883.626667s62.933333-140.544 140.416-140.586667zM678.784 1024h-199.04c0-263.210667-216.533333-479.786667-479.744-479.786667V345.173333c372.352 0 678.784 306.517333 678.784 678.826667z"></path>
</svg>

  </a>
   
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - <a class="theme-link" href="https://github.com/xianmin/hugo-theme-jane">Jane</a>
  </span>

  <span class="copyright-year">
    &copy;
    
      2018 -
    2020
    <span class="heart">
      
      <i class="iconfont">
        <svg class="icon" viewBox="0 0 1025 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="14" height="14">
  <path d="M1000.1 247.9c-15.5-37.3-37.6-70.6-65.7-98.9-54.4-54.8-125.8-85-201-85-85.7 0-166 39-221.4 107.4C456.6 103 376.3 64 290.6 64c-75.1 0-146.5 30.4-201.1 85.6-28.2 28.5-50.4 61.9-65.8 99.3-16 38.8-24 79.9-23.6 122.2 0.7 91.7 40.1 177.2 108.1 234.8 3.1 2.6 6 5.1 8.9 7.8 14.9 13.4 58 52.8 112.6 102.7 93.5 85.5 209.9 191.9 257.5 234.2 7 6.1 15.8 9.5 24.9 9.5 9.2 0 18.1-3.4 24.9-9.5 34.5-30.7 105.8-95.9 181.4-165 74.2-67.8 150.9-138 195.8-178.2 69.5-57.9 109.6-144.4 109.9-237.3 0.1-42.5-8-83.6-24-122.2z"
   fill="#8a8a8a"></path>
</svg>

      </i>
    </span><span class="author">
        Dereen
        
      </span></span>

  
  

  
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont">
        
        <svg class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="35" height="35">
  <path d="M510.866688 227.694839 95.449397 629.218702l235.761562 0-2.057869 328.796468 362.40389 0L691.55698 628.188232l241.942331-3.089361L510.866688 227.694839zM63.840492 63.962777l894.052392 0 0 131.813095L63.840492 195.775872 63.840492 63.962777 63.840492 63.962777zM63.840492 63.962777"></path>
</svg>

      </i>
    </div>
  </div>
  
<script type="text/javascript" src="/lib/jquery/jquery-3.2.1.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout-1.0.1.min.js"></script>




<script type="text/javascript" src="/js/main.dee43230127a73d039a734510fa896c89c3c7ce0cf0be0c7a7433f8fd69b76dc.js" integrity="sha256-3uQyMBJ6c9A5pzRRD6iWyJw8fODPC&#43;DHp0M/j9abdtw=" crossorigin="anonymous"></script>






<script id="tencent_analytics">
  var _hmt = _hmt || [];
  (function() {
    if (window.location.hostname === 'localhost') return;
    var hm = document.createElement("script"); hm.async = true;
	hm.src = "//tajs.qq.com/stats?sId=66547772";
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(hm, s);
  })();
</script><script id="baidu_analytics">
  var _hmt = _hmt || [];
  (function() {
    if (window.location.hostname === 'localhost') return;
    var hm = document.createElement("script"); hm.async = true;
    hm.src = "https://hm.baidu.com/hm.js?a1522558040cef0e888dd8128b86102d";
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(hm, s);
  })();
</script>

<script id="baidu_push">
  (function(){
    if (window.location.hostname === 'localhost') return;
    var bp = document.createElement('script'); bp.async = true;
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
      bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
      bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
  })();
</script>



  
    <script type="text/javascript" src="/js/load-photoswipe.js"></script>
    <script type="text/javascript" src="/lib/photoswipe/photoswipe.min.js"></script>
    <script type="text/javascript" src="/lib/photoswipe/photoswipe-ui-default.min.js"></script>
  















</body>
</html>
