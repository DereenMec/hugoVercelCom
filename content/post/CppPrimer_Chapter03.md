---
title: "CppPrimer03.字符串、向量和数组"
date: 2020-04-24T13:22:52+08:00
lastmod: 2020-04-24T13:22:52+08:00
draft: false
tags: [C++, 学习笔记]
categories: [C++ Primer 学习笔记]
author: "Dereen"
comment: true
toc: true
autoCollapseToc: false
---

除了第二章的内置类型之外，C++还定义了一个内容丰的抽象数据类型库。string和vector是两种最重要的标准库类型，前者支持可变长字符串，后者则表示可变长的集合。

<!--more-->

## 命名空间的using声明

我们目前使用的大多数库函数都属于命名空间std，例如std::cin表示从标准输入读入内容。这里使用了作用域操作符（::）的含义是：编译器应当从操作符左侧的作用域中寻找右侧那个名字。倘若在接下来的程序中我们想要省略std::部分，则只需要在文件的开始加上`using namespace std;`即可，如果我们只是想省略某个函数的std::部分，则只需要在文件的开始加上`using std::name;`即可。

⛔头文件不应包含using声明。这是因为如果头文件里有某个using声明，那么每个使用了该头文件的文件就都会有这个声明。对于某些程序来说，由于不经意间包含了一些名字，反而可能产生始料未及的名字冲突。

## 标准库类型string

标准库类型string表示可变长的字符序列。

### 定义和初始化string对象

**如何初始化类的对象是由类本身决定的。**一个类可以定义很多中初始化对象的方式，只不过这些方式之间必须有所区别；**或者是初始值的数量不同，或者是初始值的类型不同。**下面是初始化string对象最常用的方式：

```cpp
string s1;                                  // 默认初始化，空串
string s2 = s1;                             // 使用s1初始化s2
string s3 = "hello";                        // 使用字符串字面值初始化
string s4(10, 'c');                        // s4的内容是cccccccccc，10个c
```

#### 直接初始化和拷贝初始化

如果使用等号初始化一个变量，实际上执行的是**拷贝初始化（copy initialization）**，编译器把等号右侧的初始值拷贝到新创建的对象中去。与之相反，如果不使用等号，则执行的是**直接初始化（direct initialization）**。

当初始值只有一个，使用两种初始化方法都可以，但是如果像上面的第四个例子中，初始化要用到的值有多个，一般来说只能使用直接初始化。

```cpp
string s4(10, 'c');                    //一般来说只能使用直接初始化
```

### string对象上的操作

一个类除了要规定初始化其对象的方式外，还要定义对象上所能执行的操作。其中，类既能定义通过函数名调用的操作，也能定义<<，+等各种运算符在该类对象上的新含义。

|      操作      | 含义                                                    |
| :------------: | ------------------------------------------------------- |
|     os<<s      | 将s写到输出流os中，返回os                               |
|     is>>s      | 从is中读取字符串赋给s，字符串以空白分隔，返回is         |
| getline(is, s) | 从is中读取一行赋给s，返回is                             |
|   s.empty()    | s为空返回true，否则返回false                            |
|    s.size()    | 返回s中字符的个数                                       |
|      s[n]      | 返回s中第n个字符的引用，位置n从0计起                    |
|     s1+s2      | 返回s1和s2连接后的结果                                  |
|     s1=s2      | 用s2的副本代替s1中原来的字符                            |
|     s1==s2     | 如果s1和s2中所含的字符完全一样，返回true，否则返回false |
|     s1≠s2      |                                                         |
|   <，≤，>，≥   | 利用字符在字典中的而顺序进行比较，且对字母的大小写敏感  |

#### 读写string对象

我们可以使用标准库中的iostream来读写int、double等内置类型的值。同样，也可以使用IO操作符读取string对象：

```cpp
string s;                              // 空字符串
cin >> s;                              // 将string对象读入s，遇到空白停止
cout << s << endl;                     // 输出s
return 0;                              
```

💡在执行读取操作时，string对象会自动忽略开头的空白，并从第一个真正的字符开始读起，直到遇见下一处空外为止。

**和内置类型的输入输出操作一样，string对象对这种操作也是返回运算符左侧的运算对象作为其结果。**因此，多个输入或输出可以连写到一起：

```cpp
string s1, s2;
cin >> s1 >> s2;
cout << s1 << s2 << endl;
```

#### 读取未知数量的string对象

```cpp
string word;
while (cin >> word)
		cout << word << endl;
```

#### 使用getline读取一整行

```cpp
string line;
while (getline(cin, line))
		cout << line << endl;
```

💡getline是iostream中的函数，它按行读取内容并存入string对象line中，**且它会读取每一行开始的空白和最后的换行符，但是在存入line的时候并不会存入换行符。**

#### string的empty和size操作

```cpp
string line;
while (getline(cin, line))
		if (!line.empty())
				if (line.size() <= 6)
							cout << line << endl;
```

上面这段代码用到了empty和size操作，这段代码的任务是，从屏幕按行读取字符串并存入到line中，如果字符串长度小于等于6且不为空，就输出。

💡值得一提的是，size()方法的返回值类型是size_t，这种类型具有与机器无关的特性，这就为程序的可移植性做了良好的基础。

#### 比较string对象

两个string对象的比较方法是：

- 如果两个string对象的长度不同，而且较短string对象的每个字符都与较长string对象对应位置上的字符相同，就说较短string对象小于较长string对象。
- 如果两个string对象在某些位置上不一致，则string对象比较的结果其实是string对象中第一对相异字符比较的结果。

```cpp
string s1 = "Hello";
string s2 = "He";
string s3 = "HE";
```

为上面三个字符串排个序应该是s2 < s1 < s3。

#### 两个string对象相加

```cpp
string s1 = "Nice";
string s2 = " boy.";
string s3 = s1 + s2;                // s3结果为Nice boy.
```

#### 字面值和string对象相加

字符字面值的类型是char，字符串字面值的类型是const char[]。**但是因为标准库允许把字符字面值和字符串字面值转换成string对象，所以在需要string对象的地方就可以使用这两种字面值来替代。**

❗当把string对象和字符字面值及字符串字面值混在一条语句中使用时，必须确保每个加法运算符（+）的两侧运算对象至少有一个是string。

```cpp
string s4 = s1 + '.';              // 正确
string s5 = "Yo" + "oo";           // 错误，两个字符串字面值不能直接相加
```

### 处理string对象中的字符

处理string对象中的字符可以分为两个问题，一是获取string对象中的字符，二是对获取到的字符采取哪些操作。

#### 获取string对象中的所有字符

要获取string对象中的每个字符，我们可以使用**范围for循环（range for）。**

```cpp
string s = "Pretty Girl!";
for (auto &c : s)
    cout << c << endl;
```

上面这个例子的任务是将字符串s中的每一个字符取出单独输出到一行。

#### 只获取string对象中的一部分字符

使用下标运算符[]

```cpp
string s = "Pretty Girl!";
cout << s[s.size() - 1] << endl;           // 输出s中的最后一个字符
```

#### 处理字符

针对char类型，在cctype头文件中定义了一组标准库函数处理这部分工作。如下表：

|    函数     | 作用                                                         |
| :---------: | ------------------------------------------------------------ |
| isalnum(c)  | 当c是字母或数字时为真                                        |
| isalpha(c)  | 当c是字母时为真                                              |
| iscntrl(c)  | 当c是控制字符时为真                                          |
| isdigit(c)  | 当c是数字时为真                                              |
| isgraph(c)  | 当c不是空格但可打印时为真                                    |
| islower(c)  | 当c是小写字母时为真                                          |
| isprint(c)  | 当c是可打印字符时为真（即c是空格或c具有可视形式）            |
| ispunct(c)  | 当c是标点符号时为真（即c不是控制字符、数字、字母、可打印空白中的一种） |
| isspace(c)  | 当c是空白时为真（即c是空格、横向制表符、纵向制表符、回车符、换行符、进纸符中的一种） |
| isupper(c)  | 当c是大写字母时为真                                          |
| isxdigit(c) | 当c是十六进制数字时为真                                      |
| tolower(c)  | 将c转换为小写                                                |
| toupper(c)  | 将c转换为大写                                                |

例子：将”pretty pig girl.“中所有以p开头的单词的首字母都换为大写：

```cpp
string s = "pretty pig girl.";
for (auto &c : s)
		if (c == 'p')
				c = toupper(c);
cout << s << endl;                //输出：Pretty Pig girl.
```

## 标准库类型vector

标准库类型vector表示对象的集合，其中所有对象的类型都相同。集合中的每个对象都有一个与之对应的索引，索引用于访问该对象。因为vector”容纳着”其他对象，因此它也常被称作“容器”。**vector是一个类模板，**C++语言既有类模板，也有函数模板。模板本身并不是类或函数，相反可以将模板看作编译器生成类或函数编写的一份说明。编译器根据模板创建类或函数的过程称为**实例化（instantiation），**当使用模板时，需要指出编译器应把类或函数实例化成何种类型（例如：int、string）。

### 定义和初始化vector对象

和任何一种类类型一样，vector模板控制着定义和初始化向量的方法。下表列出了常用的：

| 方法                     | 含义                                       |
| ------------------------ | ------------------------------------------ |
| vector<T> v1             | 空vector，执行默认初始化                   |
| vector<T> v2(v1)         | v2中包含有v1所有元素的副本                 |
| vector<T> v2 = v1        | 等价于v2(v1)，v2中包含有v1所有元素的副本   |
| vector<T> v3(n, val)     | v3包含了n个重复的元素，每个元素的值都是val |
| vector<T> v4(n)          | v4包含了n个重复地执行了值初始化的对象      |
| vector<T> v5{a, b, c}    | v5包含了3个元素，每个元素的值              |
| vector<T> v6 = {a, b, c} | 同上                                       |

❗在使用花括号和圆括号初始化某些vector对象（例如string）时，需要考虑如下情况：

```cpp
vector<string> v5{"hi"};          // 列表初始化：v5有一个元素
vector<string> v6("hi");          // 错误：不能使用字符串字面值构建vector<string>对象
vector<string> v7(10);            // v7有10个默认初始化的元素
vector<string> v8{10};            // 同上
```

### 向vector对象中添加元素

向vector对象中添加元素可以利用其成员函数**push_back()，**该方法可以将一个元素压入（push）vector的尾部（back）。

```cpp
vector<string> vS;
string s;
while (cin >> s)
		vS.push_back(s);
```

⛔如果循环体内部包含有向vector对象添加元素的语句，则不能使用范围for循环。

### 其他vector操作

除了push_back之外，vector还提供了以下常用操作：

|       方法        | 含义                                                         |
| :---------------: | ------------------------------------------------------------ |
|     v.empty()     | 如果v不含任何元素则返回true                                  |
|     v.size()      | 返回v中元素的个数                                            |
|  v.push_back(t)   | 向v的尾端添加一个值为t的元素                                 |
|       v[n]        | 返回v中第n个位置上的元素                                     |
|      v1 = v2      | 用v2中的元素的拷贝替换v1中的元素                             |
| v1 = {a, b, c...} | 用列表中元素的拷贝替换v1中的元素                             |
|     v1 == v2      | v1和v2相等当且仅当它们的元素数量相同且每一个位置上的元素都相同 |
|      v1 ≠ v2      |                                                              |
|    <, ≤, >, ≥     | 以字典顺序比较                                               |

⛔不能使用下标来为vector对象添加元素，下标运算符只能用来访问已有的元素。

## 迭代器介绍

我们已经通过下标运算符对string对象的字符或者vector对象的元素实现了访问，其实还有另一种更通用的机制也可以实现同样的目的，这就是迭代器（iterator）。**所有标准库容器都支持迭代器，但是其中只有少数几种才同时支持下标运算符。**

💡迭代器首先是一种类型，它类似于指针，但是指针的对象可以是任何。而迭代器的对象是容器中的元素或者string对象中的字符。迭代器有有效和无效之分，这一点和指针差不多。有效的迭代器或者指向某个元素，或者指向容器中尾元素的下一位置：其他所有情况都属于无效。

### 使用迭代器

和指针不同，获取迭代器不是使用取地址符，有迭代器的类型同时拥有返回迭代器的成员函数。比如，这些类型都拥有begin和end成员，其中begin成员负责返回指向第一个元素的迭代器。end成员则负责返回指向容器“尾元素的下一个位置”的迭代器（常被称作**尾后迭代器**）。**特殊情况下如果容器为空，则begin和end返回的是同一个迭代器——尾后迭代器。**

#### 迭代器运算符

迭代器支持的一些常用运算如下表：

| 运算符         | 含义                                                         |
| -------------- | ------------------------------------------------------------ |
| *iter          | 返回迭代器iter所指元素的引用                                 |
| iter→mem       | 解引用iter并获取该元素名为mem的成员，等价于(*iter).mem       |
| #NAME?         | 令iter指示容器中的下一个元素                                 |
| —iter          | 令iter指示容器中的上一个元素                                 |
| iter1 == iter2 | 判断两个迭代器是否相等，如果两个迭代器指示的是同一元素则相等，否则不等 |
| iter1  ≠ iter2 |                                                              |

```cpp
string s = "pretty girl";
if (s.begin() != s.end()) {
		auto it = s.begin();
		*it = toupper(*it);
}
```

上面这个例子的任务是将一个字符串的第一个单词的首字母变为大写。

#### 迭代器类型

以vector为例，迭代器的类型有：std::vector::iterator和std::vector::const_iterator两种。const_iterator和常量指针差不多，能读取但不能修改它所指的元素值。相反，iterator的对象可读可写。如果vector对象或string对象是一个常量，只能使用const_iterator；如果vector对象或string对象不是常量，那么既能使用iterator也能使用const_iterator。

begin和end返回的具体类型由对象是否是常量决定，如果对象是常量，begin和end返回const_iterator；如果对象不是常量，返回iterator；**有时我们在对象不是常量的时候也想使用常量迭代器，则可以使用cbegin和cend成员函数返回常量迭代器。**

#### 结合解引用和成员访问操作

解引用迭代器可以获得迭代器所指的对象，如果该对象恰好是一个类，就有可能进一步访问它的成员。

💡(*iter).mem等于iter→mem

#### 某些对vector对象的操作会使迭代器失效

虽然vector对象可以动态的增长，但是也会有一些限制。

- 不能在范围for循环中向vector对象添加元素
- 任何一种可能改变vector对象**容量**的操作都会使vector对象的迭代器失效

### 迭代器运算

迭代器的递增运算令迭代器每次移动一个元素，**所有的标准库容器都有支持递增运算的迭代器。**除此之外，String和Vector的迭代器提供了更多额外的运算符，如下：

|     运算      | 含义                           |
| :-----------: | ------------------------------ |
|   iter + n    | 迭代器向前移动了n个元素        |
|   iter - n    | 迭代器向后移动了n个元素        |
|   iter +=n    | 将迭代器移动后的结果赋给迭代器 |
|   iter -= n   |                                |
| iter1 - iter2 | 计算两个迭代器的距离           |
|  >,  ≥, <, ≤  |                                |

例子，使用迭代器进行二分搜索：

```cpp
while (beg != end) {
    if (*midIter < target) {
        beg = midIter;
    } else if (*midIter > target) {
        end = midIter;
    } else {
        cout << midIter - vI.begin() << endl;
        break;
    }
    midIter = vI.begin() + (end - beg) / 2;
}
```

## 数组

数组也是一种容器，其与vector非常类似，不同的是其大小是固定的，不支持向数组中增加元素。

### 定义和初始化内置数组

数组是一种[复合类型](https://www.notion.so/dereen/Chapter_02-3ae7c7c1804f4e1f8f64461b9b08ec77#8501b6ff46544a29a313d4655b27d8de)。数组的声明形如a[d]，其中a是数组的名字，d是数组的维度，d必须为[常量表达式](https://www.notion.so/dereen/Chapter_02-3ae7c7c1804f4e1f8f64461b9b08ec77#a89d7a12c4fd45fba69da7cf8d41198b)。

❗和内置类型一样，如果在函数内部定义了某种内置类型的数组，那么默认初始化会令数组含有未定义的值。

#### 显式初始化数组元素

```cpp
int ia[] = {1, 2, 3};
int ib[4] = {1, 2, 3};           // 第四个元素会被默认初始化
```

#### 字符数组的特殊性

即考虑末尾的'\0'

```cpp
string sa[5] = "Hello";                  // 报错，空间不够，容纳不了那个\\0
```

#### 不允许拷贝和赋值

下面的数组操作都是不允许的。

```cpp
int a[] = {0, 1, 2};
int a2[] = a;                       // 错误
a2 = a;                             // 错误
```

#### 复杂的数组声明

和vector一样，数组能存放大多数类型的对象。例如，可以定义一个存放指针的数组。又因为数组本身就是对象，所以允许定义数组的指针及数组的引用。

```cpp
int *ptr[10];                 // ptrs是含有10个整型指针的数组
int &refs[10];                // 错误❌，引用不是对象，不能存进任何容器
int (*Parray)[10] = &arr;     // Parray指向一个含有10个整数的数组
int (&arrRef)[10] = arr;      // arrRef绑定到一个含有10个整数的数组
```

来看一个更复杂的例子：`int *(&arry)[10] = ptrs;`，要读懂这条语句，理清arry的类型，可以按照**从变量名开始，由内向外的阅读方式。**首先arry是一个引用，它绑定在一个大小为10的数组上，这个数组的元素是int *。

### 访问数组元素

在使用数组下标的时候，通常将其定义为size_t类型。size_t是一种机器相关的无符号类型，它被设计的足够大以便能表示内存中任意对象的大小。可以使用范围for循环来遍历一个数组。来看一个按分数段统计学生数目的例子：

```cpp
unsigned scores[11] = {};
unsigned grade;
while (cin >> grade) {
    if (grade <= 100 && grade >= 0)
        ++scores[grade / 10];
}
```

### 指针和数组

数组名字其实就是个指向数组首元素的指针。指向数组元素的指针也是个迭代器，可以用来遍历数组。为了让指针的使用更简单、更安全，C++标准库引入了名为begin和end函数，将数组名作为参数传入，就可以获得指向数组首元素的指针和尾后指针。

```cpp
int ia[] = {1, 2, 3, 4};
for (auto beg = begin(ia); beg != end(ia); ++beg) cout << *beg << "  ";
cout << endl;
```

#### 指针运算

指向数组元素的指针可以执行[表1](https://www.notion.so/dereen/d0f1c4e109eb44548189e5d411dc318a?v=7e760c5aa6d14ae9a34fa282d14c28b5)和[表2](https://www.notion.so/dereen/fff57b16fb034d3697b8874aea3acb19?v=60d6a1c56ab84cb58a3dd0d82f030c5e)的所有迭代器运算。**标准库类型限定的下标类型必须是无符号类型，而内置的下标运算符可以处理负值。**

```cpp
int a[] = {1, 2};
int *p = &a[2];                    // p指向a中尾后位置
cout << p[-2] << endl;             // p[-2]相当于将p向前移动2位置，输出为1
```

### C风格字符串

C风格字符串:`char s[]或char* s`等。按此习惯书写的字符串存放在字符数组中并以空字符结束（\0）。**一般利用指针来操作这些字符串。**

⛔在C++程序中最好不要使用它们。

#### C标准库String函数

下标列举了C标准库提供的一组函数，这些函数可用于操作C风格字符串，它们定义在cstring头文件中。

[C风格字符串的函数](https://www.notion.so/a8ea452acd214bbe8dec10ad8af7b884)

连接或拷贝C风格字符串也与标准string对象的同类操作差别很大。例如，要想连接两个C风格字符串可以使用下面的方法：

```cpp
const char *s1 = "Good", *s2 = " boy.";
string blank = "";
string s = s1 + blank + s2;
```

或者：

```cpp
char s1[50], s2[50];
strcpy(s1, "Good");
strcpy(s2, " boy.");
strcat(s1, s2);               // 返回s1
```

### 与旧代码的接口

#### 混用string对象和C风格字符串

- 允许使用以空字符结束的字符数组来初始化string对象或为string对象赋值
- 在string对象的加法运算中允许使用以空字符结束的字符数组作为其中一个运算对象；在string对象的复合赋值运算中允许使用空字符结束的字符数组作为右侧的运算对象。

❗上述性质反过来不成立，即无法用string对象初始化或为C风格字符串赋值。

为了完成该功能，string专门提供了一个名为c_str的成员函数。

```cpp
string s1 = "goodsssss";
const char *s = s1.c_str();
```

#### 使用数组初始化vector对象

**之前我们说过不允许使用数组为一个内置类型的数组赋初值，也不允许用vector对象初始化数组。相反的，是允许的。**只需要指出拷贝区域的首元素和尾后地址即可。

```cpp
int a[] = {1, 2, 3, 4, 5};
vector<int> vI(begin(a), end(a));
```

💡应当尽量使用vector和迭代器，避免使用内置数组和指针。

## 多维数组

C++中的多维数组，指的其实是数组的数组。

### 多维数组的初始化

```cpp
int ia[3][3] = {
    {1, 0, 0},
    {0, 1, 0},
    {0, 0, 1} 
}
int ia[3][3] = {1, 0, 0, 0, 1, 0, 0, 0, 1}; // 这种初始化和上面的结果是一样的，但是建议使用上面的
```

### 使用范围for循环遍历多维数组

```cpp
for (auto &row : ia)
    for (auto col : row)
        cout << col << "  ";
```

❗注意，第一个row必须是引用类型，这样可以防止被自动转化为指针。否则会出现编译错误。

### 指针和多维数组

当程序使用多维数组的名字时，也会自动将其转换成指向数组首元素的指针。

```cpp
int ia[3][4];
int (*p)[4] = ia;            // 括号不可省略，否则就成了指针的数组
p = &ia[2];                  // p指向ia的第三行
```