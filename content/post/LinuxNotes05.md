---
title: "LinuxNotes.存储结构与磁盘划分"
date: 2019-09-14T12:46:25+08:00
lastmod: 2019-09-14T12:46:25+08:00
draft: false
tags: [Linux]
categories: [Linux 学习笔记]
author: "Dereen"
comment: true
toc: true
autoCollapseToc: false
---

## 一切从“/”开始

在 Linux 系统中，目录、字符设备、块设备、套接字、打印机等都被抽象成了文件，即“Linux 系统中一切都是文件”。既然平时我们打交道的都是文件，那么又应该如何找到它们呢？在 Windows 操作系统中，想要找到一个文件，我们要依次进入该文件所在的磁盘分区（假设这里是 D 盘），然后在进入该分区下的具体目录，最终找到这个文件。但是在 Linux系统中并不存在 C/D/E/F 等盘符， Linux 系统中的一切文件都是从“根（ /）”目录开始的，并按照文件系统层次化标准（ FHS，Filesystem Hierarchy Standard） 采用树形结构来存放文件， 以及定义了常见目录的用途。 另外， Linux系统中的文件和目录名称是严格区分大小写的。例如， root、 rOOt、 Root、 rooT 均代表不同的目录，并且文件名称中不得包含斜杠（ /）。 Linux 系统中的文件存储结构如图所示：

![b1e13d64-ae61-4e4b-b138-4d5d9b90ddd0.png](https://storage.live.com/items/55AB66419C029DA!4111?authkey=AFBtWHxjrNHYZLw)

上面说到的FHS是根据以往无数Linux 系统用户和开发者的经验而总结出来的，是用户在Linux 系统中存储文件时需要遵守的规则，它并不是硬性的。

### Linux 系统中常见的目录名称及其相应内容

| 目录名称    | 应放置文件的内容                                            |
| ----------- | ----------------------------------------------------------- |
| /boot       | 开机所需文件—内核、开机菜单以及所需配置文件等               |
| /dev        | 以文件形式存放任何设备与接口                                |
| /etc        | 配置文件                                                    |
| /home       | 用户家目录                                                  |
| /bin        | 存放单用户模式下还可以操作的命令                            |
| /lib        | 开机时用到的函数库，以及/bin 与/sbin 下面的命令要调用的函数 |
| /sbin       | 开机过程中需要的命令                                        |
| /media      | 用于挂载设备文件的目录                                      |
| /opt        | 放置第三方的软件                                            |
| /root       | 系统管理员的家目录                                          |
| /srv        | 一些网络服务的数据文件目录                                  |
| /tmp        | 任何人均可使用的“共享”临时目录                              |
| /proc       | 虚拟文件系统，例如系统内核、进程、外部设备及网络状态等      |
| /usr/local  | 用户自行安装的软件                                          |
| /usr/sbin   | Linux 系统开机时不会使用到的软件/命令/脚本                  |
| /usr/share  | 帮助与说明文件，也可放置共享文件                            |
| /var        | 主要存放经常变化的文件，如日志                              |
| /lost+found | 当文件系统发生错误时，将一些丢失的文件片段存放在这里        |

## 物理设备的命名规则

在Linux 系统中一切都是文件，硬件设备也不例外。系统内核中的udev 设备管理器会自动把硬件名称规范起来，目的是让用户通过设备文件的名字可以猜出设备大致的属性以及分区信息等。另外udev 设备管理器的服务会一直以守护进程的形式运行并侦听内核发出的信号来管理/dev 目录下的设备文件。

### 常见的硬件设备及其文件名称

| 硬件设备       | 文件名称            |
| -------------- | ------------------- |
| IDE 设备       | /dev/hd[a-d]        |
| SCSI/SATA/U 盘 | /dev/sd[a-p]        |
| 软驱           | /dev/fd[0-1]        |
| 打印机         | /dev/lp[0-15]       |
| 光驱           | /dev/cdrom          |
| 鼠标           | /dev/mouse          |
| 磁带机         | /dev/st0 或/dev/ht0 |

由于IDE 已经慢慢退出了历史舞台，所以现在的硬盘设备大都是以“dev/sd”开头的。而一台主机上可以有多块硬盘，因此系统采用a~p来代表16块不同的硬盘，而且硬盘的分区编号也很有讲究。

- 主分区或扩展分区的编号从1开始，到4结束
- 逻辑分区从编号5开始

💡/dev 目录中 sda 设备之所以是 a，并不是由插槽决定的，而是由系统内核的识别顺序来决定的，而恰巧很多主板的插槽顺序就是系统内核的识别顺序，因此才会被命名为/dev/sda。

💡第二个知识点是对分区名称的理解错误。很多 Linux 培训讲师会告诉学员，分区的编号代表分区的个数。比如 sda3 表示这是设备上的第三个分区，而学员在做实验的时候确实也会得出这样的结果，但是这个理论知识是错误的，因为分区的数字编码不一定是强制顺延下来的，也有可能是手工指定的。因此 sda3 只能表示是编号为 3 的分区，而不能判断 sda 设备上已经存在了 3 个分区。

![e31c8120-7411-49e5-bcdb-27f727d8b2b8.png](https://storage.live.com/items/55AB66419C029DA!4112?authkey=AFBtWHxjrNHYZLw)

首先，/dev/目录中保存的应当是硬件设备文件；其次，sd 表示是存储设备；然后，a 表示系统中同类接口中第一个被识别到的设备，最后，5表示这个设备是一个逻辑分区。

![bf36c9ff-9379-4b47-9174-d62b7bc64f3a.png](https://storage.live.com/items/55AB66419C029DA!4113?authkey=AFBtWHxjrNHYZLw)

硬盘由大量的扇区组成，在**MBR分区方案**中，每个扇区的容量为512字节。其中第一个扇区最重要，它里面保存着主引导记录与分区表信息。就第一个扇区来讲，主引导记录要占用446字节，分区表为64字节，结束符占用2字节；其中分区表中每记录一个分区的信息就需要16字节，这样一来最多只有4个分区信息可以写到第一个扇区中，这4个分区就是4个主分区。

为了解决分区个数不够的问题，可以将第一个扇区的第四个分区表中16字节的空间（称之为扩展分区）拿出来指向另外一个分区。也就是说，扩展分区其实并不是一个真正的分区，而更像是一个占用 16 字节分区表空间的指针—一个指向另外一个分区的指针。这样一来，用户一般会选择使用 3 个主分区加 1 个扩展分区的方法，然后在扩展分区中创建出数个逻辑分区，从而来满足多分区（大于 4 个）的需求。

![fac404b3-a4d9-41b1-97c4-3df194ba60a8.png](https://storage.live.com/items/55AB66419C029DA!4114?authkey=AFBtWHxjrNHYZLw)

## 文件系统与数据资料

我们在硬件存储设备中执行的文件建立、写入、读取、修改等操作都是依靠文件系统来完成的。文件系统的作用是合理规划硬盘，以保证用户正常的使用需求。Linux 下常见的文件系统如下：

- Ext3：是一款日志文件系统，能够在系统异常宕机时避免文件系统资料丢失，并能自动修复数据的不一致与错误。然而，当硬盘容量较大时，所需的修复时间也会很长，而且也不能百分之百地保证资料不会丢失。它会把整个磁盘的每个写入动作的细节都预先记录下来，以便在发生异常宕机后能回溯追踪到被中断的部分，然后尝试进行修复。
- Ext4：Ext3 的改进版本，作为 RHEL 6 系统中的默认文件管理系统，它支持的存储容量高达 1EB（ 1EB=1,073,741,824GB），且能够有无限多的子目录。另外， Ext4 文件系统能够批量分配 block 块，从而极大地提高了读写效率。
- XFS：是一种高性能的日志文件系统，而且是 RHEL 7 中默认的文件管理系统，它的优势在发生意外宕机后尤其明显，即可以快速地恢复可能被破坏的文件，而且强大的日志功能只用花费极低的计算和存储性能。并且它最大可支持的存储容量为 18EB，这几乎满足了所有需求。

💡有人通过测试发现XFS文件系统相比于Ext4就文件读取性能来说有所提升，但并不巨大，所以其最大的提升应该是支持的存储容量高达了18EB。

拿到了一块新硬盘就像拿到了一张很大的白纸，我们必须要先对其进行裁切处理才能使用，这就相当于我们给硬盘分区，当然不分区也是可以的，但是一定要对硬盘进行格式化。

日常在硬盘保存的内容实在太多了，因此Linux 系统中有一个名为super block 的“硬盘地图”里面，而是在里面记录着整个文件系统的信息。因为如果把所有的文件都写入到这里面，它的体积将变得非常大，而且文件内容的查询与写入速度也会变得很慢。Linux 只是把每个文件的权限与属性记录在inode 中，而且每个文件占用一个独立的inode 表格，该表格大小为128字节。里面记录着如下信息：

![d6789837-7eb0-4678-8d6b-d6d3d7deef12.png](https://storage.live.com/items/55AB66419C029DA!4115?authkey=AFBtWHxjrNHYZLw)

而文件的实际内容保存在block 块中，一个inode的默认大小仅为128B（Ext3） ，记录一个block则消耗4B